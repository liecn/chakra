// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: et_def.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_et_5fdef_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_et_5fdef_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_et_5fdef_2eproto;
namespace ChakraProtoMsg {
class AttributeProto;
struct AttributeProtoDefaultTypeInternal;
extern AttributeProtoDefaultTypeInternal _AttributeProto_default_instance_;
class BoolList;
struct BoolListDefaultTypeInternal;
extern BoolListDefaultTypeInternal _BoolList_default_instance_;
class BytesList;
struct BytesListDefaultTypeInternal;
extern BytesListDefaultTypeInternal _BytesList_default_instance_;
class DoubleList;
struct DoubleListDefaultTypeInternal;
extern DoubleListDefaultTypeInternal _DoubleList_default_instance_;
class Fixed32List;
struct Fixed32ListDefaultTypeInternal;
extern Fixed32ListDefaultTypeInternal _Fixed32List_default_instance_;
class Fixed64List;
struct Fixed64ListDefaultTypeInternal;
extern Fixed64ListDefaultTypeInternal _Fixed64List_default_instance_;
class FloatList;
struct FloatListDefaultTypeInternal;
extern FloatListDefaultTypeInternal _FloatList_default_instance_;
class GlobalMetadata;
struct GlobalMetadataDefaultTypeInternal;
extern GlobalMetadataDefaultTypeInternal _GlobalMetadata_default_instance_;
class IOInfo;
struct IOInfoDefaultTypeInternal;
extern IOInfoDefaultTypeInternal _IOInfo_default_instance_;
class Int32List;
struct Int32ListDefaultTypeInternal;
extern Int32ListDefaultTypeInternal _Int32List_default_instance_;
class Int64List;
struct Int64ListDefaultTypeInternal;
extern Int64ListDefaultTypeInternal _Int64List_default_instance_;
class Node;
struct NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Sfixed32List;
struct Sfixed32ListDefaultTypeInternal;
extern Sfixed32ListDefaultTypeInternal _Sfixed32List_default_instance_;
class Sfixed64List;
struct Sfixed64ListDefaultTypeInternal;
extern Sfixed64ListDefaultTypeInternal _Sfixed64List_default_instance_;
class Sint32List;
struct Sint32ListDefaultTypeInternal;
extern Sint32ListDefaultTypeInternal _Sint32List_default_instance_;
class Sint64List;
struct Sint64ListDefaultTypeInternal;
extern Sint64ListDefaultTypeInternal _Sint64List_default_instance_;
class StringList;
struct StringListDefaultTypeInternal;
extern StringListDefaultTypeInternal _StringList_default_instance_;
class Tensor;
struct TensorDefaultTypeInternal;
extern TensorDefaultTypeInternal _Tensor_default_instance_;
class Uint32List;
struct Uint32ListDefaultTypeInternal;
extern Uint32ListDefaultTypeInternal _Uint32List_default_instance_;
class Uint64List;
struct Uint64ListDefaultTypeInternal;
extern Uint64ListDefaultTypeInternal _Uint64List_default_instance_;
}  // namespace ChakraProtoMsg
PROTOBUF_NAMESPACE_OPEN
template<> ::ChakraProtoMsg::AttributeProto* Arena::CreateMaybeMessage<::ChakraProtoMsg::AttributeProto>(Arena*);
template<> ::ChakraProtoMsg::BoolList* Arena::CreateMaybeMessage<::ChakraProtoMsg::BoolList>(Arena*);
template<> ::ChakraProtoMsg::BytesList* Arena::CreateMaybeMessage<::ChakraProtoMsg::BytesList>(Arena*);
template<> ::ChakraProtoMsg::DoubleList* Arena::CreateMaybeMessage<::ChakraProtoMsg::DoubleList>(Arena*);
template<> ::ChakraProtoMsg::Fixed32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Fixed32List>(Arena*);
template<> ::ChakraProtoMsg::Fixed64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Fixed64List>(Arena*);
template<> ::ChakraProtoMsg::FloatList* Arena::CreateMaybeMessage<::ChakraProtoMsg::FloatList>(Arena*);
template<> ::ChakraProtoMsg::GlobalMetadata* Arena::CreateMaybeMessage<::ChakraProtoMsg::GlobalMetadata>(Arena*);
template<> ::ChakraProtoMsg::IOInfo* Arena::CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(Arena*);
template<> ::ChakraProtoMsg::Int32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Int32List>(Arena*);
template<> ::ChakraProtoMsg::Int64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Int64List>(Arena*);
template<> ::ChakraProtoMsg::Node* Arena::CreateMaybeMessage<::ChakraProtoMsg::Node>(Arena*);
template<> ::ChakraProtoMsg::Sfixed32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sfixed32List>(Arena*);
template<> ::ChakraProtoMsg::Sfixed64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sfixed64List>(Arena*);
template<> ::ChakraProtoMsg::Sint32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sint32List>(Arena*);
template<> ::ChakraProtoMsg::Sint64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Sint64List>(Arena*);
template<> ::ChakraProtoMsg::StringList* Arena::CreateMaybeMessage<::ChakraProtoMsg::StringList>(Arena*);
template<> ::ChakraProtoMsg::Tensor* Arena::CreateMaybeMessage<::ChakraProtoMsg::Tensor>(Arena*);
template<> ::ChakraProtoMsg::Uint32List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Uint32List>(Arena*);
template<> ::ChakraProtoMsg::Uint64List* Arena::CreateMaybeMessage<::ChakraProtoMsg::Uint64List>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ChakraProtoMsg {

enum NodeType : int {
  INVALID_NODE = 0,
  METADATA_NODE = 1,
  MEM_LOAD_NODE = 2,
  MEM_STORE_NODE = 3,
  COMP_NODE = 4,
  COMM_SEND_NODE = 5,
  COMM_RECV_NODE = 6,
  COMM_COLL_NODE = 7,
  NodeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NodeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NodeType_IsValid(int value);
constexpr NodeType NodeType_MIN = INVALID_NODE;
constexpr NodeType NodeType_MAX = COMM_COLL_NODE;
constexpr int NodeType_ARRAYSIZE = NodeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeType_descriptor();
template<typename T>
inline const std::string& NodeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeType_descriptor(), enum_t_value);
}
inline bool NodeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum CollectiveCommType : int {
  ALL_REDUCE = 0,
  REDUCE = 1,
  ALL_GATHER = 2,
  GATHER = 3,
  SCATTER = 4,
  BROADCAST = 5,
  ALL_TO_ALL = 6,
  REDUCE_SCATTER = 7,
  REDUCE_SCATTER_BLOCK = 8,
  BARRIER = 9,
  CollectiveCommType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CollectiveCommType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CollectiveCommType_IsValid(int value);
constexpr CollectiveCommType CollectiveCommType_MIN = ALL_REDUCE;
constexpr CollectiveCommType CollectiveCommType_MAX = BARRIER;
constexpr int CollectiveCommType_ARRAYSIZE = CollectiveCommType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CollectiveCommType_descriptor();
template<typename T>
inline const std::string& CollectiveCommType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CollectiveCommType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CollectiveCommType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CollectiveCommType_descriptor(), enum_t_value);
}
inline bool CollectiveCommType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CollectiveCommType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CollectiveCommType>(
    CollectiveCommType_descriptor(), name, value);
}
// ===================================================================

class AttributeProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.AttributeProto) */ {
 public:
  inline AttributeProto() : AttributeProto(nullptr) {}
  ~AttributeProto() override;
  explicit PROTOBUF_CONSTEXPR AttributeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AttributeProto(const AttributeProto& from);
  AttributeProto(AttributeProto&& from) noexcept
    : AttributeProto() {
    *this = ::std::move(from);
  }

  inline AttributeProto& operator=(const AttributeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeProto& operator=(AttributeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AttributeProto& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kDoubleVal = 3,
    kDoubleList = 4,
    kFloatVal = 5,
    kFloatList = 6,
    kInt32Val = 7,
    kInt32List = 8,
    kInt64Val = 9,
    kInt64List = 10,
    kUint32Val = 11,
    kUint32List = 12,
    kUint64Val = 13,
    kUint64List = 14,
    kSint32Val = 15,
    kSint32List = 16,
    kSint64Val = 17,
    kSint64List = 18,
    kFixed32Val = 19,
    kFixed32List = 20,
    kFixed64Val = 21,
    kFixed64List = 22,
    kSfixed32Val = 23,
    kSfixed32List = 24,
    kSfixed64Val = 25,
    kSfixed64List = 26,
    kBoolVal = 27,
    kBoolList = 28,
    kStringVal = 29,
    kStringList = 30,
    kBytesVal = 31,
    kBytesList = 32,
    VALUE_NOT_SET = 0,
  };

  static inline const AttributeProto* internal_default_instance() {
    return reinterpret_cast<const AttributeProto*>(
               &_AttributeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AttributeProto& a, AttributeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AttributeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AttributeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AttributeProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AttributeProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AttributeProto& from) {
    AttributeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.AttributeProto";
  }
  protected:
  explicit AttributeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDocStringFieldNumber = 2,
    kDoubleValFieldNumber = 3,
    kDoubleListFieldNumber = 4,
    kFloatValFieldNumber = 5,
    kFloatListFieldNumber = 6,
    kInt32ValFieldNumber = 7,
    kInt32ListFieldNumber = 8,
    kInt64ValFieldNumber = 9,
    kInt64ListFieldNumber = 10,
    kUint32ValFieldNumber = 11,
    kUint32ListFieldNumber = 12,
    kUint64ValFieldNumber = 13,
    kUint64ListFieldNumber = 14,
    kSint32ValFieldNumber = 15,
    kSint32ListFieldNumber = 16,
    kSint64ValFieldNumber = 17,
    kSint64ListFieldNumber = 18,
    kFixed32ValFieldNumber = 19,
    kFixed32ListFieldNumber = 20,
    kFixed64ValFieldNumber = 21,
    kFixed64ListFieldNumber = 22,
    kSfixed32ValFieldNumber = 23,
    kSfixed32ListFieldNumber = 24,
    kSfixed64ValFieldNumber = 25,
    kSfixed64ListFieldNumber = 26,
    kBoolValFieldNumber = 27,
    kBoolListFieldNumber = 28,
    kStringValFieldNumber = 29,
    kStringListFieldNumber = 30,
    kBytesValFieldNumber = 31,
    kBytesListFieldNumber = 32,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string doc_string = 2;
  void clear_doc_string();
  const std::string& doc_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_doc_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_doc_string();
  PROTOBUF_NODISCARD std::string* release_doc_string();
  void set_allocated_doc_string(std::string* doc_string);
  private:
  const std::string& _internal_doc_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_doc_string(const std::string& value);
  std::string* _internal_mutable_doc_string();
  public:

  // double double_val = 3;
  bool has_double_val() const;
  private:
  bool _internal_has_double_val() const;
  public:
  void clear_double_val();
  double double_val() const;
  void set_double_val(double value);
  private:
  double _internal_double_val() const;
  void _internal_set_double_val(double value);
  public:

  // .ChakraProtoMsg.DoubleList double_list = 4;
  bool has_double_list() const;
  private:
  bool _internal_has_double_list() const;
  public:
  void clear_double_list();
  const ::ChakraProtoMsg::DoubleList& double_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::DoubleList* release_double_list();
  ::ChakraProtoMsg::DoubleList* mutable_double_list();
  void set_allocated_double_list(::ChakraProtoMsg::DoubleList* double_list);
  private:
  const ::ChakraProtoMsg::DoubleList& _internal_double_list() const;
  ::ChakraProtoMsg::DoubleList* _internal_mutable_double_list();
  public:
  void unsafe_arena_set_allocated_double_list(
      ::ChakraProtoMsg::DoubleList* double_list);
  ::ChakraProtoMsg::DoubleList* unsafe_arena_release_double_list();

  // float float_val = 5;
  bool has_float_val() const;
  private:
  bool _internal_has_float_val() const;
  public:
  void clear_float_val();
  float float_val() const;
  void set_float_val(float value);
  private:
  float _internal_float_val() const;
  void _internal_set_float_val(float value);
  public:

  // .ChakraProtoMsg.FloatList float_list = 6;
  bool has_float_list() const;
  private:
  bool _internal_has_float_list() const;
  public:
  void clear_float_list();
  const ::ChakraProtoMsg::FloatList& float_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::FloatList* release_float_list();
  ::ChakraProtoMsg::FloatList* mutable_float_list();
  void set_allocated_float_list(::ChakraProtoMsg::FloatList* float_list);
  private:
  const ::ChakraProtoMsg::FloatList& _internal_float_list() const;
  ::ChakraProtoMsg::FloatList* _internal_mutable_float_list();
  public:
  void unsafe_arena_set_allocated_float_list(
      ::ChakraProtoMsg::FloatList* float_list);
  ::ChakraProtoMsg::FloatList* unsafe_arena_release_float_list();

  // int32 int32_val = 7;
  bool has_int32_val() const;
  private:
  bool _internal_has_int32_val() const;
  public:
  void clear_int32_val();
  int32_t int32_val() const;
  void set_int32_val(int32_t value);
  private:
  int32_t _internal_int32_val() const;
  void _internal_set_int32_val(int32_t value);
  public:

  // .ChakraProtoMsg.Int32List int32_list = 8;
  bool has_int32_list() const;
  private:
  bool _internal_has_int32_list() const;
  public:
  void clear_int32_list();
  const ::ChakraProtoMsg::Int32List& int32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Int32List* release_int32_list();
  ::ChakraProtoMsg::Int32List* mutable_int32_list();
  void set_allocated_int32_list(::ChakraProtoMsg::Int32List* int32_list);
  private:
  const ::ChakraProtoMsg::Int32List& _internal_int32_list() const;
  ::ChakraProtoMsg::Int32List* _internal_mutable_int32_list();
  public:
  void unsafe_arena_set_allocated_int32_list(
      ::ChakraProtoMsg::Int32List* int32_list);
  ::ChakraProtoMsg::Int32List* unsafe_arena_release_int32_list();

  // int64 int64_val = 9;
  bool has_int64_val() const;
  private:
  bool _internal_has_int64_val() const;
  public:
  void clear_int64_val();
  int64_t int64_val() const;
  void set_int64_val(int64_t value);
  private:
  int64_t _internal_int64_val() const;
  void _internal_set_int64_val(int64_t value);
  public:

  // .ChakraProtoMsg.Int64List int64_list = 10;
  bool has_int64_list() const;
  private:
  bool _internal_has_int64_list() const;
  public:
  void clear_int64_list();
  const ::ChakraProtoMsg::Int64List& int64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Int64List* release_int64_list();
  ::ChakraProtoMsg::Int64List* mutable_int64_list();
  void set_allocated_int64_list(::ChakraProtoMsg::Int64List* int64_list);
  private:
  const ::ChakraProtoMsg::Int64List& _internal_int64_list() const;
  ::ChakraProtoMsg::Int64List* _internal_mutable_int64_list();
  public:
  void unsafe_arena_set_allocated_int64_list(
      ::ChakraProtoMsg::Int64List* int64_list);
  ::ChakraProtoMsg::Int64List* unsafe_arena_release_int64_list();

  // uint32 uint32_val = 11;
  bool has_uint32_val() const;
  private:
  bool _internal_has_uint32_val() const;
  public:
  void clear_uint32_val();
  uint32_t uint32_val() const;
  void set_uint32_val(uint32_t value);
  private:
  uint32_t _internal_uint32_val() const;
  void _internal_set_uint32_val(uint32_t value);
  public:

  // .ChakraProtoMsg.Uint32List uint32_list = 12;
  bool has_uint32_list() const;
  private:
  bool _internal_has_uint32_list() const;
  public:
  void clear_uint32_list();
  const ::ChakraProtoMsg::Uint32List& uint32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Uint32List* release_uint32_list();
  ::ChakraProtoMsg::Uint32List* mutable_uint32_list();
  void set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* uint32_list);
  private:
  const ::ChakraProtoMsg::Uint32List& _internal_uint32_list() const;
  ::ChakraProtoMsg::Uint32List* _internal_mutable_uint32_list();
  public:
  void unsafe_arena_set_allocated_uint32_list(
      ::ChakraProtoMsg::Uint32List* uint32_list);
  ::ChakraProtoMsg::Uint32List* unsafe_arena_release_uint32_list();

  // uint64 uint64_val = 13;
  bool has_uint64_val() const;
  private:
  bool _internal_has_uint64_val() const;
  public:
  void clear_uint64_val();
  uint64_t uint64_val() const;
  void set_uint64_val(uint64_t value);
  private:
  uint64_t _internal_uint64_val() const;
  void _internal_set_uint64_val(uint64_t value);
  public:

  // .ChakraProtoMsg.Uint64List uint64_list = 14;
  bool has_uint64_list() const;
  private:
  bool _internal_has_uint64_list() const;
  public:
  void clear_uint64_list();
  const ::ChakraProtoMsg::Uint64List& uint64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Uint64List* release_uint64_list();
  ::ChakraProtoMsg::Uint64List* mutable_uint64_list();
  void set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* uint64_list);
  private:
  const ::ChakraProtoMsg::Uint64List& _internal_uint64_list() const;
  ::ChakraProtoMsg::Uint64List* _internal_mutable_uint64_list();
  public:
  void unsafe_arena_set_allocated_uint64_list(
      ::ChakraProtoMsg::Uint64List* uint64_list);
  ::ChakraProtoMsg::Uint64List* unsafe_arena_release_uint64_list();

  // sint32 sint32_val = 15;
  bool has_sint32_val() const;
  private:
  bool _internal_has_sint32_val() const;
  public:
  void clear_sint32_val();
  int32_t sint32_val() const;
  void set_sint32_val(int32_t value);
  private:
  int32_t _internal_sint32_val() const;
  void _internal_set_sint32_val(int32_t value);
  public:

  // .ChakraProtoMsg.Sint32List sint32_list = 16;
  bool has_sint32_list() const;
  private:
  bool _internal_has_sint32_list() const;
  public:
  void clear_sint32_list();
  const ::ChakraProtoMsg::Sint32List& sint32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sint32List* release_sint32_list();
  ::ChakraProtoMsg::Sint32List* mutable_sint32_list();
  void set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* sint32_list);
  private:
  const ::ChakraProtoMsg::Sint32List& _internal_sint32_list() const;
  ::ChakraProtoMsg::Sint32List* _internal_mutable_sint32_list();
  public:
  void unsafe_arena_set_allocated_sint32_list(
      ::ChakraProtoMsg::Sint32List* sint32_list);
  ::ChakraProtoMsg::Sint32List* unsafe_arena_release_sint32_list();

  // sint64 sint64_val = 17;
  bool has_sint64_val() const;
  private:
  bool _internal_has_sint64_val() const;
  public:
  void clear_sint64_val();
  int64_t sint64_val() const;
  void set_sint64_val(int64_t value);
  private:
  int64_t _internal_sint64_val() const;
  void _internal_set_sint64_val(int64_t value);
  public:

  // .ChakraProtoMsg.Sint64List sint64_list = 18;
  bool has_sint64_list() const;
  private:
  bool _internal_has_sint64_list() const;
  public:
  void clear_sint64_list();
  const ::ChakraProtoMsg::Sint64List& sint64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sint64List* release_sint64_list();
  ::ChakraProtoMsg::Sint64List* mutable_sint64_list();
  void set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* sint64_list);
  private:
  const ::ChakraProtoMsg::Sint64List& _internal_sint64_list() const;
  ::ChakraProtoMsg::Sint64List* _internal_mutable_sint64_list();
  public:
  void unsafe_arena_set_allocated_sint64_list(
      ::ChakraProtoMsg::Sint64List* sint64_list);
  ::ChakraProtoMsg::Sint64List* unsafe_arena_release_sint64_list();

  // fixed32 fixed32_val = 19;
  bool has_fixed32_val() const;
  private:
  bool _internal_has_fixed32_val() const;
  public:
  void clear_fixed32_val();
  uint32_t fixed32_val() const;
  void set_fixed32_val(uint32_t value);
  private:
  uint32_t _internal_fixed32_val() const;
  void _internal_set_fixed32_val(uint32_t value);
  public:

  // .ChakraProtoMsg.Fixed32List fixed32_list = 20;
  bool has_fixed32_list() const;
  private:
  bool _internal_has_fixed32_list() const;
  public:
  void clear_fixed32_list();
  const ::ChakraProtoMsg::Fixed32List& fixed32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Fixed32List* release_fixed32_list();
  ::ChakraProtoMsg::Fixed32List* mutable_fixed32_list();
  void set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* fixed32_list);
  private:
  const ::ChakraProtoMsg::Fixed32List& _internal_fixed32_list() const;
  ::ChakraProtoMsg::Fixed32List* _internal_mutable_fixed32_list();
  public:
  void unsafe_arena_set_allocated_fixed32_list(
      ::ChakraProtoMsg::Fixed32List* fixed32_list);
  ::ChakraProtoMsg::Fixed32List* unsafe_arena_release_fixed32_list();

  // fixed64 fixed64_val = 21;
  bool has_fixed64_val() const;
  private:
  bool _internal_has_fixed64_val() const;
  public:
  void clear_fixed64_val();
  uint64_t fixed64_val() const;
  void set_fixed64_val(uint64_t value);
  private:
  uint64_t _internal_fixed64_val() const;
  void _internal_set_fixed64_val(uint64_t value);
  public:

  // .ChakraProtoMsg.Fixed64List fixed64_list = 22;
  bool has_fixed64_list() const;
  private:
  bool _internal_has_fixed64_list() const;
  public:
  void clear_fixed64_list();
  const ::ChakraProtoMsg::Fixed64List& fixed64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Fixed64List* release_fixed64_list();
  ::ChakraProtoMsg::Fixed64List* mutable_fixed64_list();
  void set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* fixed64_list);
  private:
  const ::ChakraProtoMsg::Fixed64List& _internal_fixed64_list() const;
  ::ChakraProtoMsg::Fixed64List* _internal_mutable_fixed64_list();
  public:
  void unsafe_arena_set_allocated_fixed64_list(
      ::ChakraProtoMsg::Fixed64List* fixed64_list);
  ::ChakraProtoMsg::Fixed64List* unsafe_arena_release_fixed64_list();

  // sfixed32 sfixed32_val = 23;
  bool has_sfixed32_val() const;
  private:
  bool _internal_has_sfixed32_val() const;
  public:
  void clear_sfixed32_val();
  int32_t sfixed32_val() const;
  void set_sfixed32_val(int32_t value);
  private:
  int32_t _internal_sfixed32_val() const;
  void _internal_set_sfixed32_val(int32_t value);
  public:

  // .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
  bool has_sfixed32_list() const;
  private:
  bool _internal_has_sfixed32_list() const;
  public:
  void clear_sfixed32_list();
  const ::ChakraProtoMsg::Sfixed32List& sfixed32_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sfixed32List* release_sfixed32_list();
  ::ChakraProtoMsg::Sfixed32List* mutable_sfixed32_list();
  void set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* sfixed32_list);
  private:
  const ::ChakraProtoMsg::Sfixed32List& _internal_sfixed32_list() const;
  ::ChakraProtoMsg::Sfixed32List* _internal_mutable_sfixed32_list();
  public:
  void unsafe_arena_set_allocated_sfixed32_list(
      ::ChakraProtoMsg::Sfixed32List* sfixed32_list);
  ::ChakraProtoMsg::Sfixed32List* unsafe_arena_release_sfixed32_list();

  // sfixed64 sfixed64_val = 25;
  bool has_sfixed64_val() const;
  private:
  bool _internal_has_sfixed64_val() const;
  public:
  void clear_sfixed64_val();
  int64_t sfixed64_val() const;
  void set_sfixed64_val(int64_t value);
  private:
  int64_t _internal_sfixed64_val() const;
  void _internal_set_sfixed64_val(int64_t value);
  public:

  // .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
  bool has_sfixed64_list() const;
  private:
  bool _internal_has_sfixed64_list() const;
  public:
  void clear_sfixed64_list();
  const ::ChakraProtoMsg::Sfixed64List& sfixed64_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::Sfixed64List* release_sfixed64_list();
  ::ChakraProtoMsg::Sfixed64List* mutable_sfixed64_list();
  void set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* sfixed64_list);
  private:
  const ::ChakraProtoMsg::Sfixed64List& _internal_sfixed64_list() const;
  ::ChakraProtoMsg::Sfixed64List* _internal_mutable_sfixed64_list();
  public:
  void unsafe_arena_set_allocated_sfixed64_list(
      ::ChakraProtoMsg::Sfixed64List* sfixed64_list);
  ::ChakraProtoMsg::Sfixed64List* unsafe_arena_release_sfixed64_list();

  // bool bool_val = 27;
  bool has_bool_val() const;
  private:
  bool _internal_has_bool_val() const;
  public:
  void clear_bool_val();
  bool bool_val() const;
  void set_bool_val(bool value);
  private:
  bool _internal_bool_val() const;
  void _internal_set_bool_val(bool value);
  public:

  // .ChakraProtoMsg.BoolList bool_list = 28;
  bool has_bool_list() const;
  private:
  bool _internal_has_bool_list() const;
  public:
  void clear_bool_list();
  const ::ChakraProtoMsg::BoolList& bool_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::BoolList* release_bool_list();
  ::ChakraProtoMsg::BoolList* mutable_bool_list();
  void set_allocated_bool_list(::ChakraProtoMsg::BoolList* bool_list);
  private:
  const ::ChakraProtoMsg::BoolList& _internal_bool_list() const;
  ::ChakraProtoMsg::BoolList* _internal_mutable_bool_list();
  public:
  void unsafe_arena_set_allocated_bool_list(
      ::ChakraProtoMsg::BoolList* bool_list);
  ::ChakraProtoMsg::BoolList* unsafe_arena_release_bool_list();

  // string string_val = 29;
  bool has_string_val() const;
  private:
  bool _internal_has_string_val() const;
  public:
  void clear_string_val();
  const std::string& string_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_val();
  PROTOBUF_NODISCARD std::string* release_string_val();
  void set_allocated_string_val(std::string* string_val);
  private:
  const std::string& _internal_string_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_val(const std::string& value);
  std::string* _internal_mutable_string_val();
  public:

  // .ChakraProtoMsg.StringList string_list = 30;
  bool has_string_list() const;
  private:
  bool _internal_has_string_list() const;
  public:
  void clear_string_list();
  const ::ChakraProtoMsg::StringList& string_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::StringList* release_string_list();
  ::ChakraProtoMsg::StringList* mutable_string_list();
  void set_allocated_string_list(::ChakraProtoMsg::StringList* string_list);
  private:
  const ::ChakraProtoMsg::StringList& _internal_string_list() const;
  ::ChakraProtoMsg::StringList* _internal_mutable_string_list();
  public:
  void unsafe_arena_set_allocated_string_list(
      ::ChakraProtoMsg::StringList* string_list);
  ::ChakraProtoMsg::StringList* unsafe_arena_release_string_list();

  // bytes bytes_val = 31;
  bool has_bytes_val() const;
  private:
  bool _internal_has_bytes_val() const;
  public:
  void clear_bytes_val();
  const std::string& bytes_val() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bytes_val(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bytes_val();
  PROTOBUF_NODISCARD std::string* release_bytes_val();
  void set_allocated_bytes_val(std::string* bytes_val);
  private:
  const std::string& _internal_bytes_val() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bytes_val(const std::string& value);
  std::string* _internal_mutable_bytes_val();
  public:

  // .ChakraProtoMsg.BytesList bytes_list = 32;
  bool has_bytes_list() const;
  private:
  bool _internal_has_bytes_list() const;
  public:
  void clear_bytes_list();
  const ::ChakraProtoMsg::BytesList& bytes_list() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::BytesList* release_bytes_list();
  ::ChakraProtoMsg::BytesList* mutable_bytes_list();
  void set_allocated_bytes_list(::ChakraProtoMsg::BytesList* bytes_list);
  private:
  const ::ChakraProtoMsg::BytesList& _internal_bytes_list() const;
  ::ChakraProtoMsg::BytesList* _internal_mutable_bytes_list();
  public:
  void unsafe_arena_set_allocated_bytes_list(
      ::ChakraProtoMsg::BytesList* bytes_list);
  ::ChakraProtoMsg::BytesList* unsafe_arena_release_bytes_list();

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.AttributeProto)
 private:
  class _Internal;
  void set_has_double_val();
  void set_has_double_list();
  void set_has_float_val();
  void set_has_float_list();
  void set_has_int32_val();
  void set_has_int32_list();
  void set_has_int64_val();
  void set_has_int64_list();
  void set_has_uint32_val();
  void set_has_uint32_list();
  void set_has_uint64_val();
  void set_has_uint64_list();
  void set_has_sint32_val();
  void set_has_sint32_list();
  void set_has_sint64_val();
  void set_has_sint64_list();
  void set_has_fixed32_val();
  void set_has_fixed32_list();
  void set_has_fixed64_val();
  void set_has_fixed64_list();
  void set_has_sfixed32_val();
  void set_has_sfixed32_list();
  void set_has_sfixed64_val();
  void set_has_sfixed64_list();
  void set_has_bool_val();
  void set_has_bool_list();
  void set_has_string_val();
  void set_has_string_list();
  void set_has_bytes_val();
  void set_has_bytes_list();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr doc_string_;
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      double double_val_;
      ::ChakraProtoMsg::DoubleList* double_list_;
      float float_val_;
      ::ChakraProtoMsg::FloatList* float_list_;
      int32_t int32_val_;
      ::ChakraProtoMsg::Int32List* int32_list_;
      int64_t int64_val_;
      ::ChakraProtoMsg::Int64List* int64_list_;
      uint32_t uint32_val_;
      ::ChakraProtoMsg::Uint32List* uint32_list_;
      uint64_t uint64_val_;
      ::ChakraProtoMsg::Uint64List* uint64_list_;
      int32_t sint32_val_;
      ::ChakraProtoMsg::Sint32List* sint32_list_;
      int64_t sint64_val_;
      ::ChakraProtoMsg::Sint64List* sint64_list_;
      uint32_t fixed32_val_;
      ::ChakraProtoMsg::Fixed32List* fixed32_list_;
      uint64_t fixed64_val_;
      ::ChakraProtoMsg::Fixed64List* fixed64_list_;
      int32_t sfixed32_val_;
      ::ChakraProtoMsg::Sfixed32List* sfixed32_list_;
      int64_t sfixed64_val_;
      ::ChakraProtoMsg::Sfixed64List* sfixed64_list_;
      bool bool_val_;
      ::ChakraProtoMsg::BoolList* bool_list_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_val_;
      ::ChakraProtoMsg::StringList* string_list_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bytes_val_;
      ::ChakraProtoMsg::BytesList* bytes_list_;
    } value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class DoubleList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.DoubleList) */ {
 public:
  inline DoubleList() : DoubleList(nullptr) {}
  ~DoubleList() override;
  explicit PROTOBUF_CONSTEXPR DoubleList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleList(const DoubleList& from);
  DoubleList(DoubleList&& from) noexcept
    : DoubleList() {
    *this = ::std::move(from);
  }

  inline DoubleList& operator=(const DoubleList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleList& operator=(DoubleList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DoubleList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleList* internal_default_instance() {
    return reinterpret_cast<const DoubleList*>(
               &_DoubleList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DoubleList& a, DoubleList& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DoubleList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DoubleList& from) {
    DoubleList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.DoubleList";
  }
  protected:
  explicit DoubleList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated double values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.DoubleList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class FloatList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.FloatList) */ {
 public:
  inline FloatList() : FloatList(nullptr) {}
  ~FloatList() override;
  explicit PROTOBUF_CONSTEXPR FloatList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatList(const FloatList& from);
  FloatList(FloatList&& from) noexcept
    : FloatList() {
    *this = ::std::move(from);
  }

  inline FloatList& operator=(const FloatList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatList& operator=(FloatList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FloatList* internal_default_instance() {
    return reinterpret_cast<const FloatList*>(
               &_FloatList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FloatList& a, FloatList& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FloatList& from) {
    FloatList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.FloatList";
  }
  protected:
  explicit FloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated float values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.FloatList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Int32List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int32List) */ {
 public:
  inline Int32List() : Int32List(nullptr) {}
  ~Int32List() override;
  explicit PROTOBUF_CONSTEXPR Int32List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int32List(const Int32List& from);
  Int32List(Int32List&& from) noexcept
    : Int32List() {
    *this = ::std::move(from);
  }

  inline Int32List& operator=(const Int32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32List& operator=(Int32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32List* internal_default_instance() {
    return reinterpret_cast<const Int32List*>(
               &_Int32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Int32List& a, Int32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Int32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int32List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int32List& from) {
    Int32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Int32List";
  }
  protected:
  explicit Int32List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int32List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Int64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Int64List) */ {
 public:
  inline Int64List() : Int64List(nullptr) {}
  ~Int64List() override;
  explicit PROTOBUF_CONSTEXPR Int64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int64List(const Int64List& from);
  Int64List(Int64List&& from) noexcept
    : Int64List() {
    *this = ::std::move(from);
  }

  inline Int64List& operator=(const Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int64List& operator=(Int64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Int64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int64List* internal_default_instance() {
    return reinterpret_cast<const Int64List*>(
               &_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Int64List& a, Int64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Int64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Int64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Int64List& from) {
    Int64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Int64List";
  }
  protected:
  explicit Int64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated int64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Int64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Uint32List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint32List) */ {
 public:
  inline Uint32List() : Uint32List(nullptr) {}
  ~Uint32List() override;
  explicit PROTOBUF_CONSTEXPR Uint32List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint32List(const Uint32List& from);
  Uint32List(Uint32List&& from) noexcept
    : Uint32List() {
    *this = ::std::move(from);
  }

  inline Uint32List& operator=(const Uint32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint32List& operator=(Uint32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint32List* internal_default_instance() {
    return reinterpret_cast<const Uint32List*>(
               &_Uint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Uint32List& a, Uint32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint32List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint32List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint32List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint32List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint32List& from) {
    Uint32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint32List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Uint32List";
  }
  protected:
  explicit Uint32List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_values() const;
  void _internal_add_values(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_values();
  public:
  uint32_t values(int index) const;
  void set_values(int index, uint32_t value);
  void add_values(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint32List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Uint64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Uint64List) */ {
 public:
  inline Uint64List() : Uint64List(nullptr) {}
  ~Uint64List() override;
  explicit PROTOBUF_CONSTEXPR Uint64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint64List(const Uint64List& from);
  Uint64List(Uint64List&& from) noexcept
    : Uint64List() {
    *this = ::std::move(from);
  }

  inline Uint64List& operator=(const Uint64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint64List& operator=(Uint64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint64List* internal_default_instance() {
    return reinterpret_cast<const Uint64List*>(
               &_Uint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Uint64List& a, Uint64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Uint64List& from) {
    Uint64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Uint64List";
  }
  protected:
  explicit Uint64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated uint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_values() const;
  void _internal_add_values(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_values();
  public:
  uint64_t values(int index) const;
  void set_values(int index, uint64_t value);
  void add_values(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Uint64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Sint32List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint32List) */ {
 public:
  inline Sint32List() : Sint32List(nullptr) {}
  ~Sint32List() override;
  explicit PROTOBUF_CONSTEXPR Sint32List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sint32List(const Sint32List& from);
  Sint32List(Sint32List&& from) noexcept
    : Sint32List() {
    *this = ::std::move(from);
  }

  inline Sint32List& operator=(const Sint32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sint32List& operator=(Sint32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sint32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sint32List* internal_default_instance() {
    return reinterpret_cast<const Sint32List*>(
               &_Sint32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Sint32List& a, Sint32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sint32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sint32List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sint32List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sint32List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sint32List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sint32List& from) {
    Sint32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sint32List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Sint32List";
  }
  protected:
  explicit Sint32List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint32List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Sint64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sint64List) */ {
 public:
  inline Sint64List() : Sint64List(nullptr) {}
  ~Sint64List() override;
  explicit PROTOBUF_CONSTEXPR Sint64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sint64List(const Sint64List& from);
  Sint64List(Sint64List&& from) noexcept
    : Sint64List() {
    *this = ::std::move(from);
  }

  inline Sint64List& operator=(const Sint64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sint64List& operator=(Sint64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sint64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sint64List* internal_default_instance() {
    return reinterpret_cast<const Sint64List*>(
               &_Sint64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Sint64List& a, Sint64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sint64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sint64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sint64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sint64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sint64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sint64List& from) {
    Sint64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sint64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Sint64List";
  }
  protected:
  explicit Sint64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sint64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sint64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable std::atomic<int> _values_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Fixed32List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed32List) */ {
 public:
  inline Fixed32List() : Fixed32List(nullptr) {}
  ~Fixed32List() override;
  explicit PROTOBUF_CONSTEXPR Fixed32List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fixed32List(const Fixed32List& from);
  Fixed32List(Fixed32List&& from) noexcept
    : Fixed32List() {
    *this = ::std::move(from);
  }

  inline Fixed32List& operator=(const Fixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed32List& operator=(Fixed32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fixed32List* internal_default_instance() {
    return reinterpret_cast<const Fixed32List*>(
               &_Fixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Fixed32List& a, Fixed32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed32List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed32List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed32List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fixed32List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fixed32List& from) {
    Fixed32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed32List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Fixed32List";
  }
  protected:
  explicit Fixed32List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated fixed32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_values() const;
  void _internal_add_values(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_values();
  public:
  uint32_t values(int index) const;
  void set_values(int index, uint32_t value);
  void add_values(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed32List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Fixed64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Fixed64List) */ {
 public:
  inline Fixed64List() : Fixed64List(nullptr) {}
  ~Fixed64List() override;
  explicit PROTOBUF_CONSTEXPR Fixed64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fixed64List(const Fixed64List& from);
  Fixed64List(Fixed64List&& from) noexcept
    : Fixed64List() {
    *this = ::std::move(from);
  }

  inline Fixed64List& operator=(const Fixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fixed64List& operator=(Fixed64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Fixed64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fixed64List* internal_default_instance() {
    return reinterpret_cast<const Fixed64List*>(
               &_Fixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Fixed64List& a, Fixed64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Fixed64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fixed64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Fixed64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Fixed64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Fixed64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Fixed64List& from) {
    Fixed64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fixed64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Fixed64List";
  }
  protected:
  explicit Fixed64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated fixed64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  uint64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_values() const;
  void _internal_add_values(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_values();
  public:
  uint64_t values(int index) const;
  void set_values(int index, uint64_t value);
  void add_values(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Fixed64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Sfixed32List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed32List) */ {
 public:
  inline Sfixed32List() : Sfixed32List(nullptr) {}
  ~Sfixed32List() override;
  explicit PROTOBUF_CONSTEXPR Sfixed32List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sfixed32List(const Sfixed32List& from);
  Sfixed32List(Sfixed32List&& from) noexcept
    : Sfixed32List() {
    *this = ::std::move(from);
  }

  inline Sfixed32List& operator=(const Sfixed32List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sfixed32List& operator=(Sfixed32List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sfixed32List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sfixed32List* internal_default_instance() {
    return reinterpret_cast<const Sfixed32List*>(
               &_Sfixed32List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Sfixed32List& a, Sfixed32List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sfixed32List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sfixed32List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sfixed32List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sfixed32List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sfixed32List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sfixed32List& from) {
    Sfixed32List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sfixed32List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Sfixed32List";
  }
  protected:
  explicit Sfixed32List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sfixed32 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int32_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_values() const;
  void _internal_add_values(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_values();
  public:
  int32_t values(int index) const;
  void set_values(int index, int32_t value);
  void add_values(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed32List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Sfixed64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Sfixed64List) */ {
 public:
  inline Sfixed64List() : Sfixed64List(nullptr) {}
  ~Sfixed64List() override;
  explicit PROTOBUF_CONSTEXPR Sfixed64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sfixed64List(const Sfixed64List& from);
  Sfixed64List(Sfixed64List&& from) noexcept
    : Sfixed64List() {
    *this = ::std::move(from);
  }

  inline Sfixed64List& operator=(const Sfixed64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sfixed64List& operator=(Sfixed64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sfixed64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sfixed64List* internal_default_instance() {
    return reinterpret_cast<const Sfixed64List*>(
               &_Sfixed64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Sfixed64List& a, Sfixed64List& b) {
    a.Swap(&b);
  }
  inline void Swap(Sfixed64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sfixed64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sfixed64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sfixed64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sfixed64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sfixed64List& from) {
    Sfixed64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sfixed64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Sfixed64List";
  }
  protected:
  explicit Sfixed64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated sfixed64 values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  int64_t _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_values() const;
  void _internal_add_values(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_values();
  public:
  int64_t values(int index) const;
  void set_values(int index, int64_t value);
  void add_values(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Sfixed64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BoolList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BoolList) */ {
 public:
  inline BoolList() : BoolList(nullptr) {}
  ~BoolList() override;
  explicit PROTOBUF_CONSTEXPR BoolList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BoolList(const BoolList& from);
  BoolList(BoolList&& from) noexcept
    : BoolList() {
    *this = ::std::move(from);
  }

  inline BoolList& operator=(const BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BoolList& operator=(BoolList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BoolList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BoolList* internal_default_instance() {
    return reinterpret_cast<const BoolList*>(
               &_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BoolList& a, BoolList& b) {
    a.Swap(&b);
  }
  inline void Swap(BoolList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BoolList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BoolList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BoolList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BoolList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BoolList& from) {
    BoolList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BoolList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.BoolList";
  }
  protected:
  explicit BoolList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bool values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BoolList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class StringList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.StringList) */ {
 public:
  inline StringList() : StringList(nullptr) {}
  ~StringList() override;
  explicit PROTOBUF_CONSTEXPR StringList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StringList(const StringList& from);
  StringList(StringList&& from) noexcept
    : StringList() {
    *this = ::std::move(from);
  }

  inline StringList& operator=(const StringList& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringList& operator=(StringList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringList& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringList* internal_default_instance() {
    return reinterpret_cast<const StringList*>(
               &_StringList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StringList& a, StringList& b) {
    a.Swap(&b);
  }
  inline void Swap(StringList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StringList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StringList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StringList& from) {
    StringList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.StringList";
  }
  protected:
  explicit StringList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated string values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.StringList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class BytesList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.BytesList) */ {
 public:
  inline BytesList() : BytesList(nullptr) {}
  ~BytesList() override;
  explicit PROTOBUF_CONSTEXPR BytesList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BytesList(const BytesList& from);
  BytesList(BytesList&& from) noexcept
    : BytesList() {
    *this = ::std::move(from);
  }

  inline BytesList& operator=(const BytesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesList& operator=(BytesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BytesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const BytesList* internal_default_instance() {
    return reinterpret_cast<const BytesList*>(
               &_BytesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(BytesList& a, BytesList& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BytesList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BytesList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BytesList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BytesList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BytesList& from) {
    BytesList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.BytesList";
  }
  protected:
  explicit BytesList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated bytes values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.BytesList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class GlobalMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.GlobalMetadata) */ {
 public:
  inline GlobalMetadata() : GlobalMetadata(nullptr) {}
  ~GlobalMetadata() override;
  explicit PROTOBUF_CONSTEXPR GlobalMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalMetadata(const GlobalMetadata& from);
  GlobalMetadata(GlobalMetadata&& from) noexcept
    : GlobalMetadata() {
    *this = ::std::move(from);
  }

  inline GlobalMetadata& operator=(const GlobalMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalMetadata& operator=(GlobalMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalMetadata* internal_default_instance() {
    return reinterpret_cast<const GlobalMetadata*>(
               &_GlobalMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GlobalMetadata& a, GlobalMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalMetadata& from) {
    GlobalMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.GlobalMetadata";
  }
  protected:
  explicit GlobalMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttrFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .ChakraProtoMsg.AttributeProto attr = 2;
  int attr_size() const;
  private:
  int _internal_attr_size() const;
  public:
  void clear_attr();
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  private:
  const ::ChakraProtoMsg::AttributeProto& _internal_attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* _internal_add_attr();
  public:
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.GlobalMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Node) */ {
 public:
  inline Node() : Node(nullptr) {}
  ~Node() override;
  explicit PROTOBUF_CONSTEXPR Node(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Node(const Node& from);
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  inline Node& operator=(Node&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Node& default_instance() {
    return *internal_default_instance();
  }
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }
  inline void Swap(Node* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Node* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Node* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Node& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Node& from) {
    Node::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Node";
  }
  protected:
  explicit Node(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCtrlDepsFieldNumber = 4,
    kDataDepsFieldNumber = 5,
    kAttrFieldNumber = 10,
    kNameFieldNumber = 2,
    kInputsFieldNumber = 8,
    kOutputsFieldNumber = 9,
    kIdFieldNumber = 1,
    kStartTimeMicrosFieldNumber = 6,
    kDurationMicrosFieldNumber = 7,
    kTypeFieldNumber = 3,
  };
  // repeated uint64 ctrl_deps = 4;
  int ctrl_deps_size() const;
  private:
  int _internal_ctrl_deps_size() const;
  public:
  void clear_ctrl_deps();
  private:
  uint64_t _internal_ctrl_deps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_ctrl_deps() const;
  void _internal_add_ctrl_deps(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_ctrl_deps();
  public:
  uint64_t ctrl_deps(int index) const;
  void set_ctrl_deps(int index, uint64_t value);
  void add_ctrl_deps(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      ctrl_deps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_ctrl_deps();

  // repeated uint64 data_deps = 5;
  int data_deps_size() const;
  private:
  int _internal_data_deps_size() const;
  public:
  void clear_data_deps();
  private:
  uint64_t _internal_data_deps(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_data_deps() const;
  void _internal_add_data_deps(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_data_deps();
  public:
  uint64_t data_deps(int index) const;
  void set_data_deps(int index, uint64_t value);
  void add_data_deps(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      data_deps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_data_deps();

  // repeated .ChakraProtoMsg.AttributeProto attr = 10;
  int attr_size() const;
  private:
  int _internal_attr_size() const;
  public:
  void clear_attr();
  ::ChakraProtoMsg::AttributeProto* mutable_attr(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
      mutable_attr();
  private:
  const ::ChakraProtoMsg::AttributeProto& _internal_attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* _internal_add_attr();
  public:
  const ::ChakraProtoMsg::AttributeProto& attr(int index) const;
  ::ChakraProtoMsg::AttributeProto* add_attr();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
      attr() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .ChakraProtoMsg.IOInfo inputs = 8;
  bool has_inputs() const;
  private:
  bool _internal_has_inputs() const;
  public:
  void clear_inputs();
  const ::ChakraProtoMsg::IOInfo& inputs() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::IOInfo* release_inputs();
  ::ChakraProtoMsg::IOInfo* mutable_inputs();
  void set_allocated_inputs(::ChakraProtoMsg::IOInfo* inputs);
  private:
  const ::ChakraProtoMsg::IOInfo& _internal_inputs() const;
  ::ChakraProtoMsg::IOInfo* _internal_mutable_inputs();
  public:
  void unsafe_arena_set_allocated_inputs(
      ::ChakraProtoMsg::IOInfo* inputs);
  ::ChakraProtoMsg::IOInfo* unsafe_arena_release_inputs();

  // .ChakraProtoMsg.IOInfo outputs = 9;
  bool has_outputs() const;
  private:
  bool _internal_has_outputs() const;
  public:
  void clear_outputs();
  const ::ChakraProtoMsg::IOInfo& outputs() const;
  PROTOBUF_NODISCARD ::ChakraProtoMsg::IOInfo* release_outputs();
  ::ChakraProtoMsg::IOInfo* mutable_outputs();
  void set_allocated_outputs(::ChakraProtoMsg::IOInfo* outputs);
  private:
  const ::ChakraProtoMsg::IOInfo& _internal_outputs() const;
  ::ChakraProtoMsg::IOInfo* _internal_mutable_outputs();
  public:
  void unsafe_arena_set_allocated_outputs(
      ::ChakraProtoMsg::IOInfo* outputs);
  ::ChakraProtoMsg::IOInfo* unsafe_arena_release_outputs();

  // uint64 id = 1;
  void clear_id();
  uint64_t id() const;
  void set_id(uint64_t value);
  private:
  uint64_t _internal_id() const;
  void _internal_set_id(uint64_t value);
  public:

  // uint64 start_time_micros = 6;
  void clear_start_time_micros();
  uint64_t start_time_micros() const;
  void set_start_time_micros(uint64_t value);
  private:
  uint64_t _internal_start_time_micros() const;
  void _internal_set_start_time_micros(uint64_t value);
  public:

  // uint64 duration_micros = 7;
  void clear_duration_micros();
  uint64_t duration_micros() const;
  void set_duration_micros(uint64_t value);
  private:
  uint64_t _internal_duration_micros() const;
  void _internal_set_duration_micros(uint64_t value);
  public:

  // .ChakraProtoMsg.NodeType type = 3;
  void clear_type();
  ::ChakraProtoMsg::NodeType type() const;
  void set_type(::ChakraProtoMsg::NodeType value);
  private:
  ::ChakraProtoMsg::NodeType _internal_type() const;
  void _internal_set_type(::ChakraProtoMsg::NodeType value);
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Node)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > ctrl_deps_;
    mutable std::atomic<int> _ctrl_deps_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > data_deps_;
    mutable std::atomic<int> _data_deps_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto > attr_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::ChakraProtoMsg::IOInfo* inputs_;
    ::ChakraProtoMsg::IOInfo* outputs_;
    uint64_t id_;
    uint64_t start_time_micros_;
    uint64_t duration_micros_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class IOInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.IOInfo) */ {
 public:
  inline IOInfo() : IOInfo(nullptr) {}
  ~IOInfo() override;
  explicit PROTOBUF_CONSTEXPR IOInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IOInfo(const IOInfo& from);
  IOInfo(IOInfo&& from) noexcept
    : IOInfo() {
    *this = ::std::move(from);
  }

  inline IOInfo& operator=(const IOInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IOInfo& operator=(IOInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IOInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IOInfo* internal_default_instance() {
    return reinterpret_cast<const IOInfo*>(
               &_IOInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(IOInfo& a, IOInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IOInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IOInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IOInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IOInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IOInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IOInfo& from) {
    IOInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IOInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.IOInfo";
  }
  protected:
  explicit IOInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kShapesFieldNumber = 2,
    kTypesFieldNumber = 3,
  };
  // string values = 1;
  void clear_values();
  const std::string& values() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_values(ArgT0&& arg0, ArgT... args);
  std::string* mutable_values();
  PROTOBUF_NODISCARD std::string* release_values();
  void set_allocated_values(std::string* values);
  private:
  const std::string& _internal_values() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_values(const std::string& value);
  std::string* _internal_mutable_values();
  public:

  // string shapes = 2;
  void clear_shapes();
  const std::string& shapes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shapes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shapes();
  PROTOBUF_NODISCARD std::string* release_shapes();
  void set_allocated_shapes(std::string* shapes);
  private:
  const std::string& _internal_shapes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shapes(const std::string& value);
  std::string* _internal_mutable_shapes();
  public:

  // string types = 3;
  void clear_types();
  const std::string& types() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_types(ArgT0&& arg0, ArgT... args);
  std::string* mutable_types();
  PROTOBUF_NODISCARD std::string* release_types();
  void set_allocated_types(std::string* types);
  private:
  const std::string& _internal_types() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_types(const std::string& value);
  std::string* _internal_mutable_types();
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.IOInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr values_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shapes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr types_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// -------------------------------------------------------------------

class Tensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChakraProtoMsg.Tensor) */ {
 public:
  inline Tensor() : Tensor(nullptr) {}
  ~Tensor() override;
  explicit PROTOBUF_CONSTEXPR Tensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Tensor(const Tensor& from);
  Tensor(Tensor&& from) noexcept
    : Tensor() {
    *this = ::std::move(from);
  }

  inline Tensor& operator=(const Tensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Tensor& operator=(Tensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Tensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const Tensor* internal_default_instance() {
    return reinterpret_cast<const Tensor*>(
               &_Tensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Tensor& a, Tensor& b) {
    a.Swap(&b);
  }
  inline void Swap(Tensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Tensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Tensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Tensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Tensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Tensor& from) {
    Tensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Tensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChakraProtoMsg.Tensor";
  }
  protected:
  explicit Tensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 6,
    kTensorIdFieldNumber = 1,
    kStorageIdFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kNumElemFieldNumber = 4,
    kElemBytesFieldNumber = 5,
  };
  // string device = 6;
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // uint64 tensor_id = 1;
  void clear_tensor_id();
  uint64_t tensor_id() const;
  void set_tensor_id(uint64_t value);
  private:
  uint64_t _internal_tensor_id() const;
  void _internal_set_tensor_id(uint64_t value);
  public:

  // uint64 storage_id = 2;
  void clear_storage_id();
  uint64_t storage_id() const;
  void set_storage_id(uint64_t value);
  private:
  uint64_t _internal_storage_id() const;
  void _internal_set_storage_id(uint64_t value);
  public:

  // uint64 offset = 3;
  void clear_offset();
  uint64_t offset() const;
  void set_offset(uint64_t value);
  private:
  uint64_t _internal_offset() const;
  void _internal_set_offset(uint64_t value);
  public:

  // uint64 num_elem = 4;
  void clear_num_elem();
  uint64_t num_elem() const;
  void set_num_elem(uint64_t value);
  private:
  uint64_t _internal_num_elem() const;
  void _internal_set_num_elem(uint64_t value);
  public:

  // uint64 elem_bytes = 5;
  void clear_elem_bytes();
  uint64_t elem_bytes() const;
  void set_elem_bytes(uint64_t value);
  private:
  uint64_t _internal_elem_bytes() const;
  void _internal_set_elem_bytes(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChakraProtoMsg.Tensor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
    uint64_t tensor_id_;
    uint64_t storage_id_;
    uint64_t offset_;
    uint64_t num_elem_;
    uint64_t elem_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_et_5fdef_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AttributeProto

// string name = 1;
inline void AttributeProto::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& AttributeProto::name() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttributeProto::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.name)
}
inline std::string* AttributeProto::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.name)
  return _s;
}
inline const std::string& AttributeProto::_internal_name() const {
  return _impl_.name_.Get();
}
inline void AttributeProto::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeProto::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* AttributeProto::release_name() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.name)
  return _impl_.name_.Release();
}
inline void AttributeProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.name)
}

// string doc_string = 2;
inline void AttributeProto::clear_doc_string() {
  _impl_.doc_string_.ClearToEmpty();
}
inline const std::string& AttributeProto::doc_string() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.doc_string)
  return _internal_doc_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AttributeProto::set_doc_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.doc_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.doc_string)
}
inline std::string* AttributeProto::mutable_doc_string() {
  std::string* _s = _internal_mutable_doc_string();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.doc_string)
  return _s;
}
inline const std::string& AttributeProto::_internal_doc_string() const {
  return _impl_.doc_string_.Get();
}
inline void AttributeProto::_internal_set_doc_string(const std::string& value) {
  
  _impl_.doc_string_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeProto::_internal_mutable_doc_string() {
  
  return _impl_.doc_string_.Mutable(GetArenaForAllocation());
}
inline std::string* AttributeProto::release_doc_string() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.doc_string)
  return _impl_.doc_string_.Release();
}
inline void AttributeProto::set_allocated_doc_string(std::string* doc_string) {
  if (doc_string != nullptr) {
    
  } else {
    
  }
  _impl_.doc_string_.SetAllocated(doc_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.doc_string_.IsDefault()) {
    _impl_.doc_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.doc_string)
}

// double double_val = 3;
inline bool AttributeProto::_internal_has_double_val() const {
  return value_case() == kDoubleVal;
}
inline bool AttributeProto::has_double_val() const {
  return _internal_has_double_val();
}
inline void AttributeProto::set_has_double_val() {
  _impl_._oneof_case_[0] = kDoubleVal;
}
inline void AttributeProto::clear_double_val() {
  if (_internal_has_double_val()) {
    _impl_.value_.double_val_ = 0;
    clear_has_value();
  }
}
inline double AttributeProto::_internal_double_val() const {
  if (_internal_has_double_val()) {
    return _impl_.value_.double_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_double_val(double value) {
  if (!_internal_has_double_val()) {
    clear_value();
    set_has_double_val();
  }
  _impl_.value_.double_val_ = value;
}
inline double AttributeProto::double_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_val)
  return _internal_double_val();
}
inline void AttributeProto::set_double_val(double value) {
  _internal_set_double_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.double_val)
}

// .ChakraProtoMsg.DoubleList double_list = 4;
inline bool AttributeProto::_internal_has_double_list() const {
  return value_case() == kDoubleList;
}
inline bool AttributeProto::has_double_list() const {
  return _internal_has_double_list();
}
inline void AttributeProto::set_has_double_list() {
  _impl_._oneof_case_[0] = kDoubleList;
}
inline void AttributeProto::clear_double_list() {
  if (_internal_has_double_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.double_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::release_double_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.double_list)
  if (_internal_has_double_list()) {
    clear_has_value();
    ::ChakraProtoMsg::DoubleList* temp = _impl_.value_.double_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.double_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::_internal_double_list() const {
  return _internal_has_double_list()
      ? *_impl_.value_.double_list_
      : reinterpret_cast< ::ChakraProtoMsg::DoubleList&>(::ChakraProtoMsg::_DoubleList_default_instance_);
}
inline const ::ChakraProtoMsg::DoubleList& AttributeProto::double_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.double_list)
  return _internal_double_list();
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::unsafe_arena_release_double_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.double_list)
  if (_internal_has_double_list()) {
    clear_has_value();
    ::ChakraProtoMsg::DoubleList* temp = _impl_.value_.double_list_;
    _impl_.value_.double_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_double_list(::ChakraProtoMsg::DoubleList* double_list) {
  clear_value();
  if (double_list) {
    set_has_double_list();
    _impl_.value_.double_list_ = double_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.double_list)
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::_internal_mutable_double_list() {
  if (!_internal_has_double_list()) {
    clear_value();
    set_has_double_list();
    _impl_.value_.double_list_ = CreateMaybeMessage< ::ChakraProtoMsg::DoubleList >(GetArenaForAllocation());
  }
  return _impl_.value_.double_list_;
}
inline ::ChakraProtoMsg::DoubleList* AttributeProto::mutable_double_list() {
  ::ChakraProtoMsg::DoubleList* _msg = _internal_mutable_double_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.double_list)
  return _msg;
}

// float float_val = 5;
inline bool AttributeProto::_internal_has_float_val() const {
  return value_case() == kFloatVal;
}
inline bool AttributeProto::has_float_val() const {
  return _internal_has_float_val();
}
inline void AttributeProto::set_has_float_val() {
  _impl_._oneof_case_[0] = kFloatVal;
}
inline void AttributeProto::clear_float_val() {
  if (_internal_has_float_val()) {
    _impl_.value_.float_val_ = 0;
    clear_has_value();
  }
}
inline float AttributeProto::_internal_float_val() const {
  if (_internal_has_float_val()) {
    return _impl_.value_.float_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_float_val(float value) {
  if (!_internal_has_float_val()) {
    clear_value();
    set_has_float_val();
  }
  _impl_.value_.float_val_ = value;
}
inline float AttributeProto::float_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_val)
  return _internal_float_val();
}
inline void AttributeProto::set_float_val(float value) {
  _internal_set_float_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.float_val)
}

// .ChakraProtoMsg.FloatList float_list = 6;
inline bool AttributeProto::_internal_has_float_list() const {
  return value_case() == kFloatList;
}
inline bool AttributeProto::has_float_list() const {
  return _internal_has_float_list();
}
inline void AttributeProto::set_has_float_list() {
  _impl_._oneof_case_[0] = kFloatList;
}
inline void AttributeProto::clear_float_list() {
  if (_internal_has_float_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.float_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::release_float_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.float_list)
  if (_internal_has_float_list()) {
    clear_has_value();
    ::ChakraProtoMsg::FloatList* temp = _impl_.value_.float_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::_internal_float_list() const {
  return _internal_has_float_list()
      ? *_impl_.value_.float_list_
      : reinterpret_cast< ::ChakraProtoMsg::FloatList&>(::ChakraProtoMsg::_FloatList_default_instance_);
}
inline const ::ChakraProtoMsg::FloatList& AttributeProto::float_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.float_list)
  return _internal_float_list();
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::unsafe_arena_release_float_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.float_list)
  if (_internal_has_float_list()) {
    clear_has_value();
    ::ChakraProtoMsg::FloatList* temp = _impl_.value_.float_list_;
    _impl_.value_.float_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_float_list(::ChakraProtoMsg::FloatList* float_list) {
  clear_value();
  if (float_list) {
    set_has_float_list();
    _impl_.value_.float_list_ = float_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.float_list)
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::_internal_mutable_float_list() {
  if (!_internal_has_float_list()) {
    clear_value();
    set_has_float_list();
    _impl_.value_.float_list_ = CreateMaybeMessage< ::ChakraProtoMsg::FloatList >(GetArenaForAllocation());
  }
  return _impl_.value_.float_list_;
}
inline ::ChakraProtoMsg::FloatList* AttributeProto::mutable_float_list() {
  ::ChakraProtoMsg::FloatList* _msg = _internal_mutable_float_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.float_list)
  return _msg;
}

// int32 int32_val = 7;
inline bool AttributeProto::_internal_has_int32_val() const {
  return value_case() == kInt32Val;
}
inline bool AttributeProto::has_int32_val() const {
  return _internal_has_int32_val();
}
inline void AttributeProto::set_has_int32_val() {
  _impl_._oneof_case_[0] = kInt32Val;
}
inline void AttributeProto::clear_int32_val() {
  if (_internal_has_int32_val()) {
    _impl_.value_.int32_val_ = 0;
    clear_has_value();
  }
}
inline int32_t AttributeProto::_internal_int32_val() const {
  if (_internal_has_int32_val()) {
    return _impl_.value_.int32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_int32_val(int32_t value) {
  if (!_internal_has_int32_val()) {
    clear_value();
    set_has_int32_val();
  }
  _impl_.value_.int32_val_ = value;
}
inline int32_t AttributeProto::int32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_val)
  return _internal_int32_val();
}
inline void AttributeProto::set_int32_val(int32_t value) {
  _internal_set_int32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int32_val)
}

// .ChakraProtoMsg.Int32List int32_list = 8;
inline bool AttributeProto::_internal_has_int32_list() const {
  return value_case() == kInt32List;
}
inline bool AttributeProto::has_int32_list() const {
  return _internal_has_int32_list();
}
inline void AttributeProto::set_has_int32_list() {
  _impl_._oneof_case_[0] = kInt32List;
}
inline void AttributeProto::clear_int32_list() {
  if (_internal_has_int32_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.int32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::release_int32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int32_list)
  if (_internal_has_int32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Int32List* temp = _impl_.value_.int32_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::_internal_int32_list() const {
  return _internal_has_int32_list()
      ? *_impl_.value_.int32_list_
      : reinterpret_cast< ::ChakraProtoMsg::Int32List&>(::ChakraProtoMsg::_Int32List_default_instance_);
}
inline const ::ChakraProtoMsg::Int32List& AttributeProto::int32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int32_list)
  return _internal_int32_list();
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::unsafe_arena_release_int32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.int32_list)
  if (_internal_has_int32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Int32List* temp = _impl_.value_.int32_list_;
    _impl_.value_.int32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_int32_list(::ChakraProtoMsg::Int32List* int32_list) {
  clear_value();
  if (int32_list) {
    set_has_int32_list();
    _impl_.value_.int32_list_ = int32_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.int32_list)
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::_internal_mutable_int32_list() {
  if (!_internal_has_int32_list()) {
    clear_value();
    set_has_int32_list();
    _impl_.value_.int32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Int32List >(GetArenaForAllocation());
  }
  return _impl_.value_.int32_list_;
}
inline ::ChakraProtoMsg::Int32List* AttributeProto::mutable_int32_list() {
  ::ChakraProtoMsg::Int32List* _msg = _internal_mutable_int32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int32_list)
  return _msg;
}

// int64 int64_val = 9;
inline bool AttributeProto::_internal_has_int64_val() const {
  return value_case() == kInt64Val;
}
inline bool AttributeProto::has_int64_val() const {
  return _internal_has_int64_val();
}
inline void AttributeProto::set_has_int64_val() {
  _impl_._oneof_case_[0] = kInt64Val;
}
inline void AttributeProto::clear_int64_val() {
  if (_internal_has_int64_val()) {
    _impl_.value_.int64_val_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t AttributeProto::_internal_int64_val() const {
  if (_internal_has_int64_val()) {
    return _impl_.value_.int64_val_;
  }
  return int64_t{0};
}
inline void AttributeProto::_internal_set_int64_val(int64_t value) {
  if (!_internal_has_int64_val()) {
    clear_value();
    set_has_int64_val();
  }
  _impl_.value_.int64_val_ = value;
}
inline int64_t AttributeProto::int64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_val)
  return _internal_int64_val();
}
inline void AttributeProto::set_int64_val(int64_t value) {
  _internal_set_int64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.int64_val)
}

// .ChakraProtoMsg.Int64List int64_list = 10;
inline bool AttributeProto::_internal_has_int64_list() const {
  return value_case() == kInt64List;
}
inline bool AttributeProto::has_int64_list() const {
  return _internal_has_int64_list();
}
inline void AttributeProto::set_has_int64_list() {
  _impl_._oneof_case_[0] = kInt64List;
}
inline void AttributeProto::clear_int64_list() {
  if (_internal_has_int64_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.int64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::release_int64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.int64_list)
  if (_internal_has_int64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Int64List* temp = _impl_.value_.int64_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::_internal_int64_list() const {
  return _internal_has_int64_list()
      ? *_impl_.value_.int64_list_
      : reinterpret_cast< ::ChakraProtoMsg::Int64List&>(::ChakraProtoMsg::_Int64List_default_instance_);
}
inline const ::ChakraProtoMsg::Int64List& AttributeProto::int64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.int64_list)
  return _internal_int64_list();
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::unsafe_arena_release_int64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.int64_list)
  if (_internal_has_int64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Int64List* temp = _impl_.value_.int64_list_;
    _impl_.value_.int64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_int64_list(::ChakraProtoMsg::Int64List* int64_list) {
  clear_value();
  if (int64_list) {
    set_has_int64_list();
    _impl_.value_.int64_list_ = int64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.int64_list)
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::_internal_mutable_int64_list() {
  if (!_internal_has_int64_list()) {
    clear_value();
    set_has_int64_list();
    _impl_.value_.int64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Int64List >(GetArenaForAllocation());
  }
  return _impl_.value_.int64_list_;
}
inline ::ChakraProtoMsg::Int64List* AttributeProto::mutable_int64_list() {
  ::ChakraProtoMsg::Int64List* _msg = _internal_mutable_int64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.int64_list)
  return _msg;
}

// uint32 uint32_val = 11;
inline bool AttributeProto::_internal_has_uint32_val() const {
  return value_case() == kUint32Val;
}
inline bool AttributeProto::has_uint32_val() const {
  return _internal_has_uint32_val();
}
inline void AttributeProto::set_has_uint32_val() {
  _impl_._oneof_case_[0] = kUint32Val;
}
inline void AttributeProto::clear_uint32_val() {
  if (_internal_has_uint32_val()) {
    _impl_.value_.uint32_val_ = 0u;
    clear_has_value();
  }
}
inline uint32_t AttributeProto::_internal_uint32_val() const {
  if (_internal_has_uint32_val()) {
    return _impl_.value_.uint32_val_;
  }
  return 0u;
}
inline void AttributeProto::_internal_set_uint32_val(uint32_t value) {
  if (!_internal_has_uint32_val()) {
    clear_value();
    set_has_uint32_val();
  }
  _impl_.value_.uint32_val_ = value;
}
inline uint32_t AttributeProto::uint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_val)
  return _internal_uint32_val();
}
inline void AttributeProto::set_uint32_val(uint32_t value) {
  _internal_set_uint32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint32_val)
}

// .ChakraProtoMsg.Uint32List uint32_list = 12;
inline bool AttributeProto::_internal_has_uint32_list() const {
  return value_case() == kUint32List;
}
inline bool AttributeProto::has_uint32_list() const {
  return _internal_has_uint32_list();
}
inline void AttributeProto::set_has_uint32_list() {
  _impl_._oneof_case_[0] = kUint32List;
}
inline void AttributeProto::clear_uint32_list() {
  if (_internal_has_uint32_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uint32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::release_uint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint32_list)
  if (_internal_has_uint32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Uint32List* temp = _impl_.value_.uint32_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::_internal_uint32_list() const {
  return _internal_has_uint32_list()
      ? *_impl_.value_.uint32_list_
      : reinterpret_cast< ::ChakraProtoMsg::Uint32List&>(::ChakraProtoMsg::_Uint32List_default_instance_);
}
inline const ::ChakraProtoMsg::Uint32List& AttributeProto::uint32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint32_list)
  return _internal_uint32_list();
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::unsafe_arena_release_uint32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.uint32_list)
  if (_internal_has_uint32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Uint32List* temp = _impl_.value_.uint32_list_;
    _impl_.value_.uint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_uint32_list(::ChakraProtoMsg::Uint32List* uint32_list) {
  clear_value();
  if (uint32_list) {
    set_has_uint32_list();
    _impl_.value_.uint32_list_ = uint32_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.uint32_list)
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::_internal_mutable_uint32_list() {
  if (!_internal_has_uint32_list()) {
    clear_value();
    set_has_uint32_list();
    _impl_.value_.uint32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Uint32List >(GetArenaForAllocation());
  }
  return _impl_.value_.uint32_list_;
}
inline ::ChakraProtoMsg::Uint32List* AttributeProto::mutable_uint32_list() {
  ::ChakraProtoMsg::Uint32List* _msg = _internal_mutable_uint32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint32_list)
  return _msg;
}

// uint64 uint64_val = 13;
inline bool AttributeProto::_internal_has_uint64_val() const {
  return value_case() == kUint64Val;
}
inline bool AttributeProto::has_uint64_val() const {
  return _internal_has_uint64_val();
}
inline void AttributeProto::set_has_uint64_val() {
  _impl_._oneof_case_[0] = kUint64Val;
}
inline void AttributeProto::clear_uint64_val() {
  if (_internal_has_uint64_val()) {
    _impl_.value_.uint64_val_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t AttributeProto::_internal_uint64_val() const {
  if (_internal_has_uint64_val()) {
    return _impl_.value_.uint64_val_;
  }
  return uint64_t{0u};
}
inline void AttributeProto::_internal_set_uint64_val(uint64_t value) {
  if (!_internal_has_uint64_val()) {
    clear_value();
    set_has_uint64_val();
  }
  _impl_.value_.uint64_val_ = value;
}
inline uint64_t AttributeProto::uint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_val)
  return _internal_uint64_val();
}
inline void AttributeProto::set_uint64_val(uint64_t value) {
  _internal_set_uint64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.uint64_val)
}

// .ChakraProtoMsg.Uint64List uint64_list = 14;
inline bool AttributeProto::_internal_has_uint64_list() const {
  return value_case() == kUint64List;
}
inline bool AttributeProto::has_uint64_list() const {
  return _internal_has_uint64_list();
}
inline void AttributeProto::set_has_uint64_list() {
  _impl_._oneof_case_[0] = kUint64List;
}
inline void AttributeProto::clear_uint64_list() {
  if (_internal_has_uint64_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.uint64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::release_uint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.uint64_list)
  if (_internal_has_uint64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Uint64List* temp = _impl_.value_.uint64_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.uint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::_internal_uint64_list() const {
  return _internal_has_uint64_list()
      ? *_impl_.value_.uint64_list_
      : reinterpret_cast< ::ChakraProtoMsg::Uint64List&>(::ChakraProtoMsg::_Uint64List_default_instance_);
}
inline const ::ChakraProtoMsg::Uint64List& AttributeProto::uint64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.uint64_list)
  return _internal_uint64_list();
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::unsafe_arena_release_uint64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.uint64_list)
  if (_internal_has_uint64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Uint64List* temp = _impl_.value_.uint64_list_;
    _impl_.value_.uint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_uint64_list(::ChakraProtoMsg::Uint64List* uint64_list) {
  clear_value();
  if (uint64_list) {
    set_has_uint64_list();
    _impl_.value_.uint64_list_ = uint64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.uint64_list)
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::_internal_mutable_uint64_list() {
  if (!_internal_has_uint64_list()) {
    clear_value();
    set_has_uint64_list();
    _impl_.value_.uint64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Uint64List >(GetArenaForAllocation());
  }
  return _impl_.value_.uint64_list_;
}
inline ::ChakraProtoMsg::Uint64List* AttributeProto::mutable_uint64_list() {
  ::ChakraProtoMsg::Uint64List* _msg = _internal_mutable_uint64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.uint64_list)
  return _msg;
}

// sint32 sint32_val = 15;
inline bool AttributeProto::_internal_has_sint32_val() const {
  return value_case() == kSint32Val;
}
inline bool AttributeProto::has_sint32_val() const {
  return _internal_has_sint32_val();
}
inline void AttributeProto::set_has_sint32_val() {
  _impl_._oneof_case_[0] = kSint32Val;
}
inline void AttributeProto::clear_sint32_val() {
  if (_internal_has_sint32_val()) {
    _impl_.value_.sint32_val_ = 0;
    clear_has_value();
  }
}
inline int32_t AttributeProto::_internal_sint32_val() const {
  if (_internal_has_sint32_val()) {
    return _impl_.value_.sint32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_sint32_val(int32_t value) {
  if (!_internal_has_sint32_val()) {
    clear_value();
    set_has_sint32_val();
  }
  _impl_.value_.sint32_val_ = value;
}
inline int32_t AttributeProto::sint32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_val)
  return _internal_sint32_val();
}
inline void AttributeProto::set_sint32_val(int32_t value) {
  _internal_set_sint32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint32_val)
}

// .ChakraProtoMsg.Sint32List sint32_list = 16;
inline bool AttributeProto::_internal_has_sint32_list() const {
  return value_case() == kSint32List;
}
inline bool AttributeProto::has_sint32_list() const {
  return _internal_has_sint32_list();
}
inline void AttributeProto::set_has_sint32_list() {
  _impl_._oneof_case_[0] = kSint32List;
}
inline void AttributeProto::clear_sint32_list() {
  if (_internal_has_sint32_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sint32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::release_sint32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint32_list)
  if (_internal_has_sint32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sint32List* temp = _impl_.value_.sint32_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::_internal_sint32_list() const {
  return _internal_has_sint32_list()
      ? *_impl_.value_.sint32_list_
      : reinterpret_cast< ::ChakraProtoMsg::Sint32List&>(::ChakraProtoMsg::_Sint32List_default_instance_);
}
inline const ::ChakraProtoMsg::Sint32List& AttributeProto::sint32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint32_list)
  return _internal_sint32_list();
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::unsafe_arena_release_sint32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sint32_list)
  if (_internal_has_sint32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sint32List* temp = _impl_.value_.sint32_list_;
    _impl_.value_.sint32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sint32_list(::ChakraProtoMsg::Sint32List* sint32_list) {
  clear_value();
  if (sint32_list) {
    set_has_sint32_list();
    _impl_.value_.sint32_list_ = sint32_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sint32_list)
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::_internal_mutable_sint32_list() {
  if (!_internal_has_sint32_list()) {
    clear_value();
    set_has_sint32_list();
    _impl_.value_.sint32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sint32List >(GetArenaForAllocation());
  }
  return _impl_.value_.sint32_list_;
}
inline ::ChakraProtoMsg::Sint32List* AttributeProto::mutable_sint32_list() {
  ::ChakraProtoMsg::Sint32List* _msg = _internal_mutable_sint32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint32_list)
  return _msg;
}

// sint64 sint64_val = 17;
inline bool AttributeProto::_internal_has_sint64_val() const {
  return value_case() == kSint64Val;
}
inline bool AttributeProto::has_sint64_val() const {
  return _internal_has_sint64_val();
}
inline void AttributeProto::set_has_sint64_val() {
  _impl_._oneof_case_[0] = kSint64Val;
}
inline void AttributeProto::clear_sint64_val() {
  if (_internal_has_sint64_val()) {
    _impl_.value_.sint64_val_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t AttributeProto::_internal_sint64_val() const {
  if (_internal_has_sint64_val()) {
    return _impl_.value_.sint64_val_;
  }
  return int64_t{0};
}
inline void AttributeProto::_internal_set_sint64_val(int64_t value) {
  if (!_internal_has_sint64_val()) {
    clear_value();
    set_has_sint64_val();
  }
  _impl_.value_.sint64_val_ = value;
}
inline int64_t AttributeProto::sint64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_val)
  return _internal_sint64_val();
}
inline void AttributeProto::set_sint64_val(int64_t value) {
  _internal_set_sint64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sint64_val)
}

// .ChakraProtoMsg.Sint64List sint64_list = 18;
inline bool AttributeProto::_internal_has_sint64_list() const {
  return value_case() == kSint64List;
}
inline bool AttributeProto::has_sint64_list() const {
  return _internal_has_sint64_list();
}
inline void AttributeProto::set_has_sint64_list() {
  _impl_._oneof_case_[0] = kSint64List;
}
inline void AttributeProto::clear_sint64_list() {
  if (_internal_has_sint64_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sint64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::release_sint64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sint64_list)
  if (_internal_has_sint64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sint64List* temp = _impl_.value_.sint64_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::_internal_sint64_list() const {
  return _internal_has_sint64_list()
      ? *_impl_.value_.sint64_list_
      : reinterpret_cast< ::ChakraProtoMsg::Sint64List&>(::ChakraProtoMsg::_Sint64List_default_instance_);
}
inline const ::ChakraProtoMsg::Sint64List& AttributeProto::sint64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sint64_list)
  return _internal_sint64_list();
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::unsafe_arena_release_sint64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sint64_list)
  if (_internal_has_sint64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sint64List* temp = _impl_.value_.sint64_list_;
    _impl_.value_.sint64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sint64_list(::ChakraProtoMsg::Sint64List* sint64_list) {
  clear_value();
  if (sint64_list) {
    set_has_sint64_list();
    _impl_.value_.sint64_list_ = sint64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sint64_list)
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::_internal_mutable_sint64_list() {
  if (!_internal_has_sint64_list()) {
    clear_value();
    set_has_sint64_list();
    _impl_.value_.sint64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sint64List >(GetArenaForAllocation());
  }
  return _impl_.value_.sint64_list_;
}
inline ::ChakraProtoMsg::Sint64List* AttributeProto::mutable_sint64_list() {
  ::ChakraProtoMsg::Sint64List* _msg = _internal_mutable_sint64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sint64_list)
  return _msg;
}

// fixed32 fixed32_val = 19;
inline bool AttributeProto::_internal_has_fixed32_val() const {
  return value_case() == kFixed32Val;
}
inline bool AttributeProto::has_fixed32_val() const {
  return _internal_has_fixed32_val();
}
inline void AttributeProto::set_has_fixed32_val() {
  _impl_._oneof_case_[0] = kFixed32Val;
}
inline void AttributeProto::clear_fixed32_val() {
  if (_internal_has_fixed32_val()) {
    _impl_.value_.fixed32_val_ = 0u;
    clear_has_value();
  }
}
inline uint32_t AttributeProto::_internal_fixed32_val() const {
  if (_internal_has_fixed32_val()) {
    return _impl_.value_.fixed32_val_;
  }
  return 0u;
}
inline void AttributeProto::_internal_set_fixed32_val(uint32_t value) {
  if (!_internal_has_fixed32_val()) {
    clear_value();
    set_has_fixed32_val();
  }
  _impl_.value_.fixed32_val_ = value;
}
inline uint32_t AttributeProto::fixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_val)
  return _internal_fixed32_val();
}
inline void AttributeProto::set_fixed32_val(uint32_t value) {
  _internal_set_fixed32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed32_val)
}

// .ChakraProtoMsg.Fixed32List fixed32_list = 20;
inline bool AttributeProto::_internal_has_fixed32_list() const {
  return value_case() == kFixed32List;
}
inline bool AttributeProto::has_fixed32_list() const {
  return _internal_has_fixed32_list();
}
inline void AttributeProto::set_has_fixed32_list() {
  _impl_._oneof_case_[0] = kFixed32List;
}
inline void AttributeProto::clear_fixed32_list() {
  if (_internal_has_fixed32_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.fixed32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::release_fixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed32_list)
  if (_internal_has_fixed32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Fixed32List* temp = _impl_.value_.fixed32_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.fixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::_internal_fixed32_list() const {
  return _internal_has_fixed32_list()
      ? *_impl_.value_.fixed32_list_
      : reinterpret_cast< ::ChakraProtoMsg::Fixed32List&>(::ChakraProtoMsg::_Fixed32List_default_instance_);
}
inline const ::ChakraProtoMsg::Fixed32List& AttributeProto::fixed32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed32_list)
  return _internal_fixed32_list();
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::unsafe_arena_release_fixed32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.fixed32_list)
  if (_internal_has_fixed32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Fixed32List* temp = _impl_.value_.fixed32_list_;
    _impl_.value_.fixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_fixed32_list(::ChakraProtoMsg::Fixed32List* fixed32_list) {
  clear_value();
  if (fixed32_list) {
    set_has_fixed32_list();
    _impl_.value_.fixed32_list_ = fixed32_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.fixed32_list)
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::_internal_mutable_fixed32_list() {
  if (!_internal_has_fixed32_list()) {
    clear_value();
    set_has_fixed32_list();
    _impl_.value_.fixed32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Fixed32List >(GetArenaForAllocation());
  }
  return _impl_.value_.fixed32_list_;
}
inline ::ChakraProtoMsg::Fixed32List* AttributeProto::mutable_fixed32_list() {
  ::ChakraProtoMsg::Fixed32List* _msg = _internal_mutable_fixed32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed32_list)
  return _msg;
}

// fixed64 fixed64_val = 21;
inline bool AttributeProto::_internal_has_fixed64_val() const {
  return value_case() == kFixed64Val;
}
inline bool AttributeProto::has_fixed64_val() const {
  return _internal_has_fixed64_val();
}
inline void AttributeProto::set_has_fixed64_val() {
  _impl_._oneof_case_[0] = kFixed64Val;
}
inline void AttributeProto::clear_fixed64_val() {
  if (_internal_has_fixed64_val()) {
    _impl_.value_.fixed64_val_ = uint64_t{0u};
    clear_has_value();
  }
}
inline uint64_t AttributeProto::_internal_fixed64_val() const {
  if (_internal_has_fixed64_val()) {
    return _impl_.value_.fixed64_val_;
  }
  return uint64_t{0u};
}
inline void AttributeProto::_internal_set_fixed64_val(uint64_t value) {
  if (!_internal_has_fixed64_val()) {
    clear_value();
    set_has_fixed64_val();
  }
  _impl_.value_.fixed64_val_ = value;
}
inline uint64_t AttributeProto::fixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_val)
  return _internal_fixed64_val();
}
inline void AttributeProto::set_fixed64_val(uint64_t value) {
  _internal_set_fixed64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.fixed64_val)
}

// .ChakraProtoMsg.Fixed64List fixed64_list = 22;
inline bool AttributeProto::_internal_has_fixed64_list() const {
  return value_case() == kFixed64List;
}
inline bool AttributeProto::has_fixed64_list() const {
  return _internal_has_fixed64_list();
}
inline void AttributeProto::set_has_fixed64_list() {
  _impl_._oneof_case_[0] = kFixed64List;
}
inline void AttributeProto::clear_fixed64_list() {
  if (_internal_has_fixed64_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.fixed64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::release_fixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.fixed64_list)
  if (_internal_has_fixed64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Fixed64List* temp = _impl_.value_.fixed64_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.fixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::_internal_fixed64_list() const {
  return _internal_has_fixed64_list()
      ? *_impl_.value_.fixed64_list_
      : reinterpret_cast< ::ChakraProtoMsg::Fixed64List&>(::ChakraProtoMsg::_Fixed64List_default_instance_);
}
inline const ::ChakraProtoMsg::Fixed64List& AttributeProto::fixed64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.fixed64_list)
  return _internal_fixed64_list();
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::unsafe_arena_release_fixed64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.fixed64_list)
  if (_internal_has_fixed64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Fixed64List* temp = _impl_.value_.fixed64_list_;
    _impl_.value_.fixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_fixed64_list(::ChakraProtoMsg::Fixed64List* fixed64_list) {
  clear_value();
  if (fixed64_list) {
    set_has_fixed64_list();
    _impl_.value_.fixed64_list_ = fixed64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.fixed64_list)
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::_internal_mutable_fixed64_list() {
  if (!_internal_has_fixed64_list()) {
    clear_value();
    set_has_fixed64_list();
    _impl_.value_.fixed64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Fixed64List >(GetArenaForAllocation());
  }
  return _impl_.value_.fixed64_list_;
}
inline ::ChakraProtoMsg::Fixed64List* AttributeProto::mutable_fixed64_list() {
  ::ChakraProtoMsg::Fixed64List* _msg = _internal_mutable_fixed64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.fixed64_list)
  return _msg;
}

// sfixed32 sfixed32_val = 23;
inline bool AttributeProto::_internal_has_sfixed32_val() const {
  return value_case() == kSfixed32Val;
}
inline bool AttributeProto::has_sfixed32_val() const {
  return _internal_has_sfixed32_val();
}
inline void AttributeProto::set_has_sfixed32_val() {
  _impl_._oneof_case_[0] = kSfixed32Val;
}
inline void AttributeProto::clear_sfixed32_val() {
  if (_internal_has_sfixed32_val()) {
    _impl_.value_.sfixed32_val_ = 0;
    clear_has_value();
  }
}
inline int32_t AttributeProto::_internal_sfixed32_val() const {
  if (_internal_has_sfixed32_val()) {
    return _impl_.value_.sfixed32_val_;
  }
  return 0;
}
inline void AttributeProto::_internal_set_sfixed32_val(int32_t value) {
  if (!_internal_has_sfixed32_val()) {
    clear_value();
    set_has_sfixed32_val();
  }
  _impl_.value_.sfixed32_val_ = value;
}
inline int32_t AttributeProto::sfixed32_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_val)
  return _internal_sfixed32_val();
}
inline void AttributeProto::set_sfixed32_val(int32_t value) {
  _internal_set_sfixed32_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed32_val)
}

// .ChakraProtoMsg.Sfixed32List sfixed32_list = 24;
inline bool AttributeProto::_internal_has_sfixed32_list() const {
  return value_case() == kSfixed32List;
}
inline bool AttributeProto::has_sfixed32_list() const {
  return _internal_has_sfixed32_list();
}
inline void AttributeProto::set_has_sfixed32_list() {
  _impl_._oneof_case_[0] = kSfixed32List;
}
inline void AttributeProto::clear_sfixed32_list() {
  if (_internal_has_sfixed32_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sfixed32_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::release_sfixed32_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed32_list)
  if (_internal_has_sfixed32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sfixed32List* temp = _impl_.value_.sfixed32_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sfixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::_internal_sfixed32_list() const {
  return _internal_has_sfixed32_list()
      ? *_impl_.value_.sfixed32_list_
      : reinterpret_cast< ::ChakraProtoMsg::Sfixed32List&>(::ChakraProtoMsg::_Sfixed32List_default_instance_);
}
inline const ::ChakraProtoMsg::Sfixed32List& AttributeProto::sfixed32_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return _internal_sfixed32_list();
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::unsafe_arena_release_sfixed32_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sfixed32_list)
  if (_internal_has_sfixed32_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sfixed32List* temp = _impl_.value_.sfixed32_list_;
    _impl_.value_.sfixed32_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sfixed32_list(::ChakraProtoMsg::Sfixed32List* sfixed32_list) {
  clear_value();
  if (sfixed32_list) {
    set_has_sfixed32_list();
    _impl_.value_.sfixed32_list_ = sfixed32_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sfixed32_list)
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::_internal_mutable_sfixed32_list() {
  if (!_internal_has_sfixed32_list()) {
    clear_value();
    set_has_sfixed32_list();
    _impl_.value_.sfixed32_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sfixed32List >(GetArenaForAllocation());
  }
  return _impl_.value_.sfixed32_list_;
}
inline ::ChakraProtoMsg::Sfixed32List* AttributeProto::mutable_sfixed32_list() {
  ::ChakraProtoMsg::Sfixed32List* _msg = _internal_mutable_sfixed32_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed32_list)
  return _msg;
}

// sfixed64 sfixed64_val = 25;
inline bool AttributeProto::_internal_has_sfixed64_val() const {
  return value_case() == kSfixed64Val;
}
inline bool AttributeProto::has_sfixed64_val() const {
  return _internal_has_sfixed64_val();
}
inline void AttributeProto::set_has_sfixed64_val() {
  _impl_._oneof_case_[0] = kSfixed64Val;
}
inline void AttributeProto::clear_sfixed64_val() {
  if (_internal_has_sfixed64_val()) {
    _impl_.value_.sfixed64_val_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t AttributeProto::_internal_sfixed64_val() const {
  if (_internal_has_sfixed64_val()) {
    return _impl_.value_.sfixed64_val_;
  }
  return int64_t{0};
}
inline void AttributeProto::_internal_set_sfixed64_val(int64_t value) {
  if (!_internal_has_sfixed64_val()) {
    clear_value();
    set_has_sfixed64_val();
  }
  _impl_.value_.sfixed64_val_ = value;
}
inline int64_t AttributeProto::sfixed64_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_val)
  return _internal_sfixed64_val();
}
inline void AttributeProto::set_sfixed64_val(int64_t value) {
  _internal_set_sfixed64_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.sfixed64_val)
}

// .ChakraProtoMsg.Sfixed64List sfixed64_list = 26;
inline bool AttributeProto::_internal_has_sfixed64_list() const {
  return value_case() == kSfixed64List;
}
inline bool AttributeProto::has_sfixed64_list() const {
  return _internal_has_sfixed64_list();
}
inline void AttributeProto::set_has_sfixed64_list() {
  _impl_._oneof_case_[0] = kSfixed64List;
}
inline void AttributeProto::clear_sfixed64_list() {
  if (_internal_has_sfixed64_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.sfixed64_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::release_sfixed64_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.sfixed64_list)
  if (_internal_has_sfixed64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sfixed64List* temp = _impl_.value_.sfixed64_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.sfixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::_internal_sfixed64_list() const {
  return _internal_has_sfixed64_list()
      ? *_impl_.value_.sfixed64_list_
      : reinterpret_cast< ::ChakraProtoMsg::Sfixed64List&>(::ChakraProtoMsg::_Sfixed64List_default_instance_);
}
inline const ::ChakraProtoMsg::Sfixed64List& AttributeProto::sfixed64_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return _internal_sfixed64_list();
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::unsafe_arena_release_sfixed64_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.sfixed64_list)
  if (_internal_has_sfixed64_list()) {
    clear_has_value();
    ::ChakraProtoMsg::Sfixed64List* temp = _impl_.value_.sfixed64_list_;
    _impl_.value_.sfixed64_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_sfixed64_list(::ChakraProtoMsg::Sfixed64List* sfixed64_list) {
  clear_value();
  if (sfixed64_list) {
    set_has_sfixed64_list();
    _impl_.value_.sfixed64_list_ = sfixed64_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.sfixed64_list)
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::_internal_mutable_sfixed64_list() {
  if (!_internal_has_sfixed64_list()) {
    clear_value();
    set_has_sfixed64_list();
    _impl_.value_.sfixed64_list_ = CreateMaybeMessage< ::ChakraProtoMsg::Sfixed64List >(GetArenaForAllocation());
  }
  return _impl_.value_.sfixed64_list_;
}
inline ::ChakraProtoMsg::Sfixed64List* AttributeProto::mutable_sfixed64_list() {
  ::ChakraProtoMsg::Sfixed64List* _msg = _internal_mutable_sfixed64_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.sfixed64_list)
  return _msg;
}

// bool bool_val = 27;
inline bool AttributeProto::_internal_has_bool_val() const {
  return value_case() == kBoolVal;
}
inline bool AttributeProto::has_bool_val() const {
  return _internal_has_bool_val();
}
inline void AttributeProto::set_has_bool_val() {
  _impl_._oneof_case_[0] = kBoolVal;
}
inline void AttributeProto::clear_bool_val() {
  if (_internal_has_bool_val()) {
    _impl_.value_.bool_val_ = false;
    clear_has_value();
  }
}
inline bool AttributeProto::_internal_bool_val() const {
  if (_internal_has_bool_val()) {
    return _impl_.value_.bool_val_;
  }
  return false;
}
inline void AttributeProto::_internal_set_bool_val(bool value) {
  if (!_internal_has_bool_val()) {
    clear_value();
    set_has_bool_val();
  }
  _impl_.value_.bool_val_ = value;
}
inline bool AttributeProto::bool_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_val)
  return _internal_bool_val();
}
inline void AttributeProto::set_bool_val(bool value) {
  _internal_set_bool_val(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bool_val)
}

// .ChakraProtoMsg.BoolList bool_list = 28;
inline bool AttributeProto::_internal_has_bool_list() const {
  return value_case() == kBoolList;
}
inline bool AttributeProto::has_bool_list() const {
  return _internal_has_bool_list();
}
inline void AttributeProto::set_has_bool_list() {
  _impl_._oneof_case_[0] = kBoolList;
}
inline void AttributeProto::clear_bool_list() {
  if (_internal_has_bool_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.bool_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::release_bool_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bool_list)
  if (_internal_has_bool_list()) {
    clear_has_value();
    ::ChakraProtoMsg::BoolList* temp = _impl_.value_.bool_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::_internal_bool_list() const {
  return _internal_has_bool_list()
      ? *_impl_.value_.bool_list_
      : reinterpret_cast< ::ChakraProtoMsg::BoolList&>(::ChakraProtoMsg::_BoolList_default_instance_);
}
inline const ::ChakraProtoMsg::BoolList& AttributeProto::bool_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bool_list)
  return _internal_bool_list();
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::unsafe_arena_release_bool_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.bool_list)
  if (_internal_has_bool_list()) {
    clear_has_value();
    ::ChakraProtoMsg::BoolList* temp = _impl_.value_.bool_list_;
    _impl_.value_.bool_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_bool_list(::ChakraProtoMsg::BoolList* bool_list) {
  clear_value();
  if (bool_list) {
    set_has_bool_list();
    _impl_.value_.bool_list_ = bool_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.bool_list)
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::_internal_mutable_bool_list() {
  if (!_internal_has_bool_list()) {
    clear_value();
    set_has_bool_list();
    _impl_.value_.bool_list_ = CreateMaybeMessage< ::ChakraProtoMsg::BoolList >(GetArenaForAllocation());
  }
  return _impl_.value_.bool_list_;
}
inline ::ChakraProtoMsg::BoolList* AttributeProto::mutable_bool_list() {
  ::ChakraProtoMsg::BoolList* _msg = _internal_mutable_bool_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bool_list)
  return _msg;
}

// string string_val = 29;
inline bool AttributeProto::_internal_has_string_val() const {
  return value_case() == kStringVal;
}
inline bool AttributeProto::has_string_val() const {
  return _internal_has_string_val();
}
inline void AttributeProto::set_has_string_val() {
  _impl_._oneof_case_[0] = kStringVal;
}
inline void AttributeProto::clear_string_val() {
  if (_internal_has_string_val()) {
    _impl_.value_.string_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeProto::string_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_val)
  return _internal_string_val();
}
template <typename ArgT0, typename... ArgT>
inline void AttributeProto::set_string_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.string_val)
}
inline std::string* AttributeProto::mutable_string_val() {
  std::string* _s = _internal_mutable_string_val();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_val)
  return _s;
}
inline const std::string& AttributeProto::_internal_string_val() const {
  if (_internal_has_string_val()) {
    return _impl_.value_.string_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeProto::_internal_set_string_val(const std::string& value) {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  _impl_.value_.string_val_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeProto::_internal_mutable_string_val() {
  if (!_internal_has_string_val()) {
    clear_value();
    set_has_string_val();
    _impl_.value_.string_val_.InitDefault();
  }
  return _impl_.value_.string_val_.Mutable(      GetArenaForAllocation());
}
inline std::string* AttributeProto::release_string_val() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_val)
  if (_internal_has_string_val()) {
    clear_has_value();
    return _impl_.value_.string_val_.Release();
  } else {
    return nullptr;
  }
}
inline void AttributeProto::set_allocated_string_val(std::string* string_val) {
  if (has_value()) {
    clear_value();
  }
  if (string_val != nullptr) {
    set_has_string_val();
    _impl_.value_.string_val_.InitAllocated(string_val, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.string_val)
}

// .ChakraProtoMsg.StringList string_list = 30;
inline bool AttributeProto::_internal_has_string_list() const {
  return value_case() == kStringList;
}
inline bool AttributeProto::has_string_list() const {
  return _internal_has_string_list();
}
inline void AttributeProto::set_has_string_list() {
  _impl_._oneof_case_[0] = kStringList;
}
inline void AttributeProto::clear_string_list() {
  if (_internal_has_string_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.string_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::StringList* AttributeProto::release_string_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.string_list)
  if (_internal_has_string_list()) {
    clear_has_value();
    ::ChakraProtoMsg::StringList* temp = _impl_.value_.string_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.string_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::_internal_string_list() const {
  return _internal_has_string_list()
      ? *_impl_.value_.string_list_
      : reinterpret_cast< ::ChakraProtoMsg::StringList&>(::ChakraProtoMsg::_StringList_default_instance_);
}
inline const ::ChakraProtoMsg::StringList& AttributeProto::string_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.string_list)
  return _internal_string_list();
}
inline ::ChakraProtoMsg::StringList* AttributeProto::unsafe_arena_release_string_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.string_list)
  if (_internal_has_string_list()) {
    clear_has_value();
    ::ChakraProtoMsg::StringList* temp = _impl_.value_.string_list_;
    _impl_.value_.string_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_string_list(::ChakraProtoMsg::StringList* string_list) {
  clear_value();
  if (string_list) {
    set_has_string_list();
    _impl_.value_.string_list_ = string_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.string_list)
}
inline ::ChakraProtoMsg::StringList* AttributeProto::_internal_mutable_string_list() {
  if (!_internal_has_string_list()) {
    clear_value();
    set_has_string_list();
    _impl_.value_.string_list_ = CreateMaybeMessage< ::ChakraProtoMsg::StringList >(GetArenaForAllocation());
  }
  return _impl_.value_.string_list_;
}
inline ::ChakraProtoMsg::StringList* AttributeProto::mutable_string_list() {
  ::ChakraProtoMsg::StringList* _msg = _internal_mutable_string_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.string_list)
  return _msg;
}

// bytes bytes_val = 31;
inline bool AttributeProto::_internal_has_bytes_val() const {
  return value_case() == kBytesVal;
}
inline bool AttributeProto::has_bytes_val() const {
  return _internal_has_bytes_val();
}
inline void AttributeProto::set_has_bytes_val() {
  _impl_._oneof_case_[0] = kBytesVal;
}
inline void AttributeProto::clear_bytes_val() {
  if (_internal_has_bytes_val()) {
    _impl_.value_.bytes_val_.Destroy();
    clear_has_value();
  }
}
inline const std::string& AttributeProto::bytes_val() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_val)
  return _internal_bytes_val();
}
template <typename ArgT0, typename... ArgT>
inline void AttributeProto::set_bytes_val(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  _impl_.value_.bytes_val_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.AttributeProto.bytes_val)
}
inline std::string* AttributeProto::mutable_bytes_val() {
  std::string* _s = _internal_mutable_bytes_val();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_val)
  return _s;
}
inline const std::string& AttributeProto::_internal_bytes_val() const {
  if (_internal_has_bytes_val()) {
    return _impl_.value_.bytes_val_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AttributeProto::_internal_set_bytes_val(const std::string& value) {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  _impl_.value_.bytes_val_.Set(value, GetArenaForAllocation());
}
inline std::string* AttributeProto::_internal_mutable_bytes_val() {
  if (!_internal_has_bytes_val()) {
    clear_value();
    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitDefault();
  }
  return _impl_.value_.bytes_val_.Mutable(      GetArenaForAllocation());
}
inline std::string* AttributeProto::release_bytes_val() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_val)
  if (_internal_has_bytes_val()) {
    clear_has_value();
    return _impl_.value_.bytes_val_.Release();
  } else {
    return nullptr;
  }
}
inline void AttributeProto::set_allocated_bytes_val(std::string* bytes_val) {
  if (has_value()) {
    clear_value();
  }
  if (bytes_val != nullptr) {
    set_has_bytes_val();
    _impl_.value_.bytes_val_.InitAllocated(bytes_val, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.AttributeProto.bytes_val)
}

// .ChakraProtoMsg.BytesList bytes_list = 32;
inline bool AttributeProto::_internal_has_bytes_list() const {
  return value_case() == kBytesList;
}
inline bool AttributeProto::has_bytes_list() const {
  return _internal_has_bytes_list();
}
inline void AttributeProto::set_has_bytes_list() {
  _impl_._oneof_case_[0] = kBytesList;
}
inline void AttributeProto::clear_bytes_list() {
  if (_internal_has_bytes_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.value_.bytes_list_;
    }
    clear_has_value();
  }
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::release_bytes_list() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.AttributeProto.bytes_list)
  if (_internal_has_bytes_list()) {
    clear_has_value();
    ::ChakraProtoMsg::BytesList* temp = _impl_.value_.bytes_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.value_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::_internal_bytes_list() const {
  return _internal_has_bytes_list()
      ? *_impl_.value_.bytes_list_
      : reinterpret_cast< ::ChakraProtoMsg::BytesList&>(::ChakraProtoMsg::_BytesList_default_instance_);
}
inline const ::ChakraProtoMsg::BytesList& AttributeProto::bytes_list() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.AttributeProto.bytes_list)
  return _internal_bytes_list();
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::unsafe_arena_release_bytes_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ChakraProtoMsg.AttributeProto.bytes_list)
  if (_internal_has_bytes_list()) {
    clear_has_value();
    ::ChakraProtoMsg::BytesList* temp = _impl_.value_.bytes_list_;
    _impl_.value_.bytes_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AttributeProto::unsafe_arena_set_allocated_bytes_list(::ChakraProtoMsg::BytesList* bytes_list) {
  clear_value();
  if (bytes_list) {
    set_has_bytes_list();
    _impl_.value_.bytes_list_ = bytes_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.AttributeProto.bytes_list)
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::_internal_mutable_bytes_list() {
  if (!_internal_has_bytes_list()) {
    clear_value();
    set_has_bytes_list();
    _impl_.value_.bytes_list_ = CreateMaybeMessage< ::ChakraProtoMsg::BytesList >(GetArenaForAllocation());
  }
  return _impl_.value_.bytes_list_;
}
inline ::ChakraProtoMsg::BytesList* AttributeProto::mutable_bytes_list() {
  ::ChakraProtoMsg::BytesList* _msg = _internal_mutable_bytes_list();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.AttributeProto.bytes_list)
  return _msg;
}

inline bool AttributeProto::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void AttributeProto::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline AttributeProto::ValueCase AttributeProto::value_case() const {
  return AttributeProto::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// DoubleList

// repeated double values = 1;
inline int DoubleList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int DoubleList::values_size() const {
  return _internal_values_size();
}
inline void DoubleList::clear_values() {
  _impl_.values_.Clear();
}
inline double DoubleList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline double DoubleList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.DoubleList.values)
  return _internal_values(index);
}
inline void DoubleList::set_values(int index, double value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.DoubleList.values)
}
inline void DoubleList::_internal_add_values(double value) {
  _impl_.values_.Add(value);
}
inline void DoubleList::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.DoubleList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleList::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
DoubleList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.DoubleList.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleList::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
DoubleList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.DoubleList.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// FloatList

// repeated float values = 1;
inline int FloatList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int FloatList::values_size() const {
  return _internal_values_size();
}
inline void FloatList::clear_values() {
  _impl_.values_.Clear();
}
inline float FloatList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline float FloatList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.FloatList.values)
  return _internal_values(index);
}
inline void FloatList::set_values(int index, float value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.FloatList.values)
}
inline void FloatList::_internal_add_values(float value) {
  _impl_.values_.Add(value);
}
inline void FloatList::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.FloatList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatList::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
FloatList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.FloatList.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatList::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
FloatList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.FloatList.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int32List

// repeated int32 values = 1;
inline int Int32List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int32List::values_size() const {
  return _internal_values_size();
}
inline void Int32List::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t Int32List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t Int32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int32List.values)
  return _internal_values(index);
}
inline void Int32List::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int32List.values)
}
inline void Int32List::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void Int32List::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int32List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Int32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int32List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Int32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int32List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Int64List

// repeated int64 values = 1;
inline int Int64List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Int64List::values_size() const {
  return _internal_values_size();
}
inline void Int64List::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t Int64List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t Int64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Int64List.values)
  return _internal_values(index);
}
inline void Int64List::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Int64List.values)
}
inline void Int64List::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void Int64List::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Int64List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Int64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Int64List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Int64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Int64List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint32List

// repeated uint32 values = 1;
inline int Uint32List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint32List::values_size() const {
  return _internal_values_size();
}
inline void Uint32List::clear_values() {
  _impl_.values_.Clear();
}
inline uint32_t Uint32List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint32_t Uint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint32List.values)
  return _internal_values(index);
}
inline void Uint32List::set_values(int index, uint32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint32List.values)
}
inline void Uint32List::_internal_add_values(uint32_t value) {
  _impl_.values_.Add(value);
}
inline void Uint32List::add_values(uint32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint32List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Uint32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint32List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Uint32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint32List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Uint64List

// repeated uint64 values = 1;
inline int Uint64List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Uint64List::values_size() const {
  return _internal_values_size();
}
inline void Uint64List::clear_values() {
  _impl_.values_.Clear();
}
inline uint64_t Uint64List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint64_t Uint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Uint64List.values)
  return _internal_values(index);
}
inline void Uint64List::set_values(int index, uint64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Uint64List.values)
}
inline void Uint64List::_internal_add_values(uint64_t value) {
  _impl_.values_.Add(value);
}
inline void Uint64List::add_values(uint64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Uint64List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Uint64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Uint64List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Uint64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Uint64List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Sint32List

// repeated sint32 values = 1;
inline int Sint32List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Sint32List::values_size() const {
  return _internal_values_size();
}
inline void Sint32List::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t Sint32List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t Sint32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint32List.values)
  return _internal_values(index);
}
inline void Sint32List::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint32List.values)
}
inline void Sint32List::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void Sint32List::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint32List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Sint32List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Sint32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint32List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Sint32List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Sint32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint32List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Sint64List

// repeated sint64 values = 1;
inline int Sint64List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Sint64List::values_size() const {
  return _internal_values_size();
}
inline void Sint64List::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t Sint64List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t Sint64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sint64List.values)
  return _internal_values(index);
}
inline void Sint64List::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sint64List.values)
}
inline void Sint64List::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void Sint64List::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sint64List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Sint64List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Sint64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sint64List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Sint64List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Sint64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sint64List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Fixed32List

// repeated fixed32 values = 1;
inline int Fixed32List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Fixed32List::values_size() const {
  return _internal_values_size();
}
inline void Fixed32List::clear_values() {
  _impl_.values_.Clear();
}
inline uint32_t Fixed32List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint32_t Fixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed32List.values)
  return _internal_values(index);
}
inline void Fixed32List::set_values(int index, uint32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed32List.values)
}
inline void Fixed32List::_internal_add_values(uint32_t value) {
  _impl_.values_.Add(value);
}
inline void Fixed32List::add_values(uint32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed32List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Fixed32List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Fixed32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed32List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Fixed32List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Fixed32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed32List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Fixed64List

// repeated fixed64 values = 1;
inline int Fixed64List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Fixed64List::values_size() const {
  return _internal_values_size();
}
inline void Fixed64List::clear_values() {
  _impl_.values_.Clear();
}
inline uint64_t Fixed64List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline uint64_t Fixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Fixed64List.values)
  return _internal_values(index);
}
inline void Fixed64List::set_values(int index, uint64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Fixed64List.values)
}
inline void Fixed64List::_internal_add_values(uint64_t value) {
  _impl_.values_.Add(value);
}
inline void Fixed64List::add_values(uint64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Fixed64List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Fixed64List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Fixed64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Fixed64List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Fixed64List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Fixed64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Fixed64List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Sfixed32List

// repeated sfixed32 values = 1;
inline int Sfixed32List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Sfixed32List::values_size() const {
  return _internal_values_size();
}
inline void Sfixed32List::clear_values() {
  _impl_.values_.Clear();
}
inline int32_t Sfixed32List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int32_t Sfixed32List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed32List.values)
  return _internal_values(index);
}
inline void Sfixed32List::set_values(int index, int32_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed32List.values)
}
inline void Sfixed32List::_internal_add_values(int32_t value) {
  _impl_.values_.Add(value);
}
inline void Sfixed32List::add_values(int32_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed32List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Sfixed32List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Sfixed32List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed32List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Sfixed32List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Sfixed32List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed32List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// Sfixed64List

// repeated sfixed64 values = 1;
inline int Sfixed64List::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int Sfixed64List::values_size() const {
  return _internal_values_size();
}
inline void Sfixed64List::clear_values() {
  _impl_.values_.Clear();
}
inline int64_t Sfixed64List::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline int64_t Sfixed64List::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Sfixed64List.values)
  return _internal_values(index);
}
inline void Sfixed64List::set_values(int index, int64_t value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Sfixed64List.values)
}
inline void Sfixed64List::_internal_add_values(int64_t value) {
  _impl_.values_.Add(value);
}
inline void Sfixed64List::add_values(int64_t value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Sfixed64List.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Sfixed64List::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
Sfixed64List::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Sfixed64List.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Sfixed64List::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
Sfixed64List::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Sfixed64List.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// BoolList

// repeated bool values = 1;
inline int BoolList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int BoolList::values_size() const {
  return _internal_values_size();
}
inline void BoolList::clear_values() {
  _impl_.values_.Clear();
}
inline bool BoolList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline bool BoolList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BoolList.values)
  return _internal_values(index);
}
inline void BoolList::set_values(int index, bool value) {
  _impl_.values_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BoolList.values)
}
inline void BoolList::_internal_add_values(bool value) {
  _impl_.values_.Add(value);
}
inline void BoolList::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BoolList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolList::_internal_values() const {
  return _impl_.values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
BoolList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BoolList.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolList::_internal_mutable_values() {
  return &_impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
BoolList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BoolList.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// StringList

// repeated string values = 1;
inline int StringList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int StringList::values_size() const {
  return _internal_values_size();
}
inline void StringList::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* StringList::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.StringList.values)
  return _s;
}
inline const std::string& StringList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& StringList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.StringList.values)
  return _internal_values(index);
}
inline std::string* StringList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.StringList.values)
  return _impl_.values_.Mutable(index);
}
inline void StringList::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::set_values(int index, const char* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.StringList.values)
}
inline std::string* StringList::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void StringList::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.StringList.values)
}
inline void StringList::add_values(const char* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.StringList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StringList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.StringList.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StringList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.StringList.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// BytesList

// repeated bytes values = 1;
inline int BytesList::_internal_values_size() const {
  return _impl_.values_.size();
}
inline int BytesList::values_size() const {
  return _internal_values_size();
}
inline void BytesList::clear_values() {
  _impl_.values_.Clear();
}
inline std::string* BytesList::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:ChakraProtoMsg.BytesList.values)
  return _s;
}
inline const std::string& BytesList::_internal_values(int index) const {
  return _impl_.values_.Get(index);
}
inline const std::string& BytesList::values(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.BytesList.values)
  return _internal_values(index);
}
inline std::string* BytesList::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.BytesList.values)
  return _impl_.values_.Mutable(index);
}
inline void BytesList::set_values(int index, const std::string& value) {
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, std::string&& value) {
  _impl_.values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::set_values(int index, const void* value, size_t size) {
  _impl_.values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ChakraProtoMsg.BytesList.values)
}
inline std::string* BytesList::_internal_add_values() {
  return _impl_.values_.Add();
}
inline void BytesList::add_values(const std::string& value) {
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(std::string&& value) {
  _impl_.values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ChakraProtoMsg.BytesList.values)
}
inline void BytesList::add_values(const void* value, size_t size) {
  _impl_.values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ChakraProtoMsg.BytesList.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BytesList::values() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.BytesList.values)
  return _impl_.values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BytesList::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.BytesList.values)
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// GlobalMetadata

// string version = 1;
inline void GlobalMetadata::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& GlobalMetadata::version() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GlobalMetadata::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.GlobalMetadata.version)
}
inline std::string* GlobalMetadata::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.version)
  return _s;
}
inline const std::string& GlobalMetadata::_internal_version() const {
  return _impl_.version_.Get();
}
inline void GlobalMetadata::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* GlobalMetadata::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* GlobalMetadata::release_version() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.GlobalMetadata.version)
  return _impl_.version_.Release();
}
inline void GlobalMetadata::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.GlobalMetadata.version)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 2;
inline int GlobalMetadata::_internal_attr_size() const {
  return _impl_.attr_.size();
}
inline int GlobalMetadata::attr_size() const {
  return _internal_attr_size();
}
inline void GlobalMetadata::clear_attr() {
  _impl_.attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.GlobalMetadata.attr)
  return _impl_.attr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
GlobalMetadata::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.GlobalMetadata.attr)
  return &_impl_.attr_;
}
inline const ::ChakraProtoMsg::AttributeProto& GlobalMetadata::_internal_attr(int index) const {
  return _impl_.attr_.Get(index);
}
inline const ::ChakraProtoMsg::AttributeProto& GlobalMetadata::attr(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.GlobalMetadata.attr)
  return _internal_attr(index);
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::_internal_add_attr() {
  return _impl_.attr_.Add();
}
inline ::ChakraProtoMsg::AttributeProto* GlobalMetadata::add_attr() {
  ::ChakraProtoMsg::AttributeProto* _add = _internal_add_attr();
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.GlobalMetadata.attr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
GlobalMetadata::attr() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.GlobalMetadata.attr)
  return _impl_.attr_;
}

// -------------------------------------------------------------------

// Node

// uint64 id = 1;
inline void Node::clear_id() {
  _impl_.id_ = uint64_t{0u};
}
inline uint64_t Node::_internal_id() const {
  return _impl_.id_;
}
inline uint64_t Node::id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.id)
  return _internal_id();
}
inline void Node::_internal_set_id(uint64_t value) {
  
  _impl_.id_ = value;
}
inline void Node::set_id(uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.id)
}

// string name = 2;
inline void Node::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Node::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.name)
}
inline std::string* Node::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.name)
  return _s;
}
inline const std::string& Node::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Node::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Node::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Node::release_name() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.name)
  return _impl_.name_.Release();
}
inline void Node::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.name)
}

// .ChakraProtoMsg.NodeType type = 3;
inline void Node::clear_type() {
  _impl_.type_ = 0;
}
inline ::ChakraProtoMsg::NodeType Node::_internal_type() const {
  return static_cast< ::ChakraProtoMsg::NodeType >(_impl_.type_);
}
inline ::ChakraProtoMsg::NodeType Node::type() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.type)
  return _internal_type();
}
inline void Node::_internal_set_type(::ChakraProtoMsg::NodeType value) {
  
  _impl_.type_ = value;
}
inline void Node::set_type(::ChakraProtoMsg::NodeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.type)
}

// repeated uint64 ctrl_deps = 4;
inline int Node::_internal_ctrl_deps_size() const {
  return _impl_.ctrl_deps_.size();
}
inline int Node::ctrl_deps_size() const {
  return _internal_ctrl_deps_size();
}
inline void Node::clear_ctrl_deps() {
  _impl_.ctrl_deps_.Clear();
}
inline uint64_t Node::_internal_ctrl_deps(int index) const {
  return _impl_.ctrl_deps_.Get(index);
}
inline uint64_t Node::ctrl_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.ctrl_deps)
  return _internal_ctrl_deps(index);
}
inline void Node::set_ctrl_deps(int index, uint64_t value) {
  _impl_.ctrl_deps_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.ctrl_deps)
}
inline void Node::_internal_add_ctrl_deps(uint64_t value) {
  _impl_.ctrl_deps_.Add(value);
}
inline void Node::add_ctrl_deps(uint64_t value) {
  _internal_add_ctrl_deps(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.ctrl_deps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Node::_internal_ctrl_deps() const {
  return _impl_.ctrl_deps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Node::ctrl_deps() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.ctrl_deps)
  return _internal_ctrl_deps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Node::_internal_mutable_ctrl_deps() {
  return &_impl_.ctrl_deps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Node::mutable_ctrl_deps() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.ctrl_deps)
  return _internal_mutable_ctrl_deps();
}

// repeated uint64 data_deps = 5;
inline int Node::_internal_data_deps_size() const {
  return _impl_.data_deps_.size();
}
inline int Node::data_deps_size() const {
  return _internal_data_deps_size();
}
inline void Node::clear_data_deps() {
  _impl_.data_deps_.Clear();
}
inline uint64_t Node::_internal_data_deps(int index) const {
  return _impl_.data_deps_.Get(index);
}
inline uint64_t Node::data_deps(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.data_deps)
  return _internal_data_deps(index);
}
inline void Node::set_data_deps(int index, uint64_t value) {
  _impl_.data_deps_.Set(index, value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.data_deps)
}
inline void Node::_internal_add_data_deps(uint64_t value) {
  _impl_.data_deps_.Add(value);
}
inline void Node::add_data_deps(uint64_t value) {
  _internal_add_data_deps(value);
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.data_deps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Node::_internal_data_deps() const {
  return _impl_.data_deps_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
Node::data_deps() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.data_deps)
  return _internal_data_deps();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Node::_internal_mutable_data_deps() {
  return &_impl_.data_deps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
Node::mutable_data_deps() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.data_deps)
  return _internal_mutable_data_deps();
}

// uint64 start_time_micros = 6;
inline void Node::clear_start_time_micros() {
  _impl_.start_time_micros_ = uint64_t{0u};
}
inline uint64_t Node::_internal_start_time_micros() const {
  return _impl_.start_time_micros_;
}
inline uint64_t Node::start_time_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.start_time_micros)
  return _internal_start_time_micros();
}
inline void Node::_internal_set_start_time_micros(uint64_t value) {
  
  _impl_.start_time_micros_ = value;
}
inline void Node::set_start_time_micros(uint64_t value) {
  _internal_set_start_time_micros(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.start_time_micros)
}

// uint64 duration_micros = 7;
inline void Node::clear_duration_micros() {
  _impl_.duration_micros_ = uint64_t{0u};
}
inline uint64_t Node::_internal_duration_micros() const {
  return _impl_.duration_micros_;
}
inline uint64_t Node::duration_micros() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.duration_micros)
  return _internal_duration_micros();
}
inline void Node::_internal_set_duration_micros(uint64_t value) {
  
  _impl_.duration_micros_ = value;
}
inline void Node::set_duration_micros(uint64_t value) {
  _internal_set_duration_micros(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Node.duration_micros)
}

// .ChakraProtoMsg.IOInfo inputs = 8;
inline bool Node::_internal_has_inputs() const {
  return this != internal_default_instance() && _impl_.inputs_ != nullptr;
}
inline bool Node::has_inputs() const {
  return _internal_has_inputs();
}
inline void Node::clear_inputs() {
  if (GetArenaForAllocation() == nullptr && _impl_.inputs_ != nullptr) {
    delete _impl_.inputs_;
  }
  _impl_.inputs_ = nullptr;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_inputs() const {
  const ::ChakraProtoMsg::IOInfo* p = _impl_.inputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChakraProtoMsg::IOInfo&>(
      ::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline const ::ChakraProtoMsg::IOInfo& Node::inputs() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.inputs)
  return _internal_inputs();
}
inline void Node::unsafe_arena_set_allocated_inputs(
    ::ChakraProtoMsg::IOInfo* inputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.inputs_);
  }
  _impl_.inputs_ = inputs;
  if (inputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.Node.inputs)
}
inline ::ChakraProtoMsg::IOInfo* Node::release_inputs() {
  
  ::ChakraProtoMsg::IOInfo* temp = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::unsafe_arena_release_inputs() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.inputs)
  
  ::ChakraProtoMsg::IOInfo* temp = _impl_.inputs_;
  _impl_.inputs_ = nullptr;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::_internal_mutable_inputs() {
  
  if (_impl_.inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArenaForAllocation());
    _impl_.inputs_ = p;
  }
  return _impl_.inputs_;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_inputs() {
  ::ChakraProtoMsg::IOInfo* _msg = _internal_mutable_inputs();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.inputs)
  return _msg;
}
inline void Node::set_allocated_inputs(::ChakraProtoMsg::IOInfo* inputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.inputs_;
  }
  if (inputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inputs);
    if (message_arena != submessage_arena) {
      inputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.inputs)
}

// .ChakraProtoMsg.IOInfo outputs = 9;
inline bool Node::_internal_has_outputs() const {
  return this != internal_default_instance() && _impl_.outputs_ != nullptr;
}
inline bool Node::has_outputs() const {
  return _internal_has_outputs();
}
inline void Node::clear_outputs() {
  if (GetArenaForAllocation() == nullptr && _impl_.outputs_ != nullptr) {
    delete _impl_.outputs_;
  }
  _impl_.outputs_ = nullptr;
}
inline const ::ChakraProtoMsg::IOInfo& Node::_internal_outputs() const {
  const ::ChakraProtoMsg::IOInfo* p = _impl_.outputs_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChakraProtoMsg::IOInfo&>(
      ::ChakraProtoMsg::_IOInfo_default_instance_);
}
inline const ::ChakraProtoMsg::IOInfo& Node::outputs() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.outputs)
  return _internal_outputs();
}
inline void Node::unsafe_arena_set_allocated_outputs(
    ::ChakraProtoMsg::IOInfo* outputs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.outputs_);
  }
  _impl_.outputs_ = outputs;
  if (outputs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChakraProtoMsg.Node.outputs)
}
inline ::ChakraProtoMsg::IOInfo* Node::release_outputs() {
  
  ::ChakraProtoMsg::IOInfo* temp = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::unsafe_arena_release_outputs() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Node.outputs)
  
  ::ChakraProtoMsg::IOInfo* temp = _impl_.outputs_;
  _impl_.outputs_ = nullptr;
  return temp;
}
inline ::ChakraProtoMsg::IOInfo* Node::_internal_mutable_outputs() {
  
  if (_impl_.outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChakraProtoMsg::IOInfo>(GetArenaForAllocation());
    _impl_.outputs_ = p;
  }
  return _impl_.outputs_;
}
inline ::ChakraProtoMsg::IOInfo* Node::mutable_outputs() {
  ::ChakraProtoMsg::IOInfo* _msg = _internal_mutable_outputs();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.outputs)
  return _msg;
}
inline void Node::set_allocated_outputs(::ChakraProtoMsg::IOInfo* outputs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.outputs_;
  }
  if (outputs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(outputs);
    if (message_arena != submessage_arena) {
      outputs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Node.outputs)
}

// repeated .ChakraProtoMsg.AttributeProto attr = 10;
inline int Node::_internal_attr_size() const {
  return _impl_.attr_.size();
}
inline int Node::attr_size() const {
  return _internal_attr_size();
}
inline void Node::clear_attr() {
  _impl_.attr_.Clear();
}
inline ::ChakraProtoMsg::AttributeProto* Node::mutable_attr(int index) {
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Node.attr)
  return _impl_.attr_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >*
Node::mutable_attr() {
  // @@protoc_insertion_point(field_mutable_list:ChakraProtoMsg.Node.attr)
  return &_impl_.attr_;
}
inline const ::ChakraProtoMsg::AttributeProto& Node::_internal_attr(int index) const {
  return _impl_.attr_.Get(index);
}
inline const ::ChakraProtoMsg::AttributeProto& Node::attr(int index) const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Node.attr)
  return _internal_attr(index);
}
inline ::ChakraProtoMsg::AttributeProto* Node::_internal_add_attr() {
  return _impl_.attr_.Add();
}
inline ::ChakraProtoMsg::AttributeProto* Node::add_attr() {
  ::ChakraProtoMsg::AttributeProto* _add = _internal_add_attr();
  // @@protoc_insertion_point(field_add:ChakraProtoMsg.Node.attr)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChakraProtoMsg::AttributeProto >&
Node::attr() const {
  // @@protoc_insertion_point(field_list:ChakraProtoMsg.Node.attr)
  return _impl_.attr_;
}

// -------------------------------------------------------------------

// IOInfo

// string values = 1;
inline void IOInfo::clear_values() {
  _impl_.values_.ClearToEmpty();
}
inline const std::string& IOInfo::values() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.values)
  return _internal_values();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IOInfo::set_values(ArgT0&& arg0, ArgT... args) {
 
 _impl_.values_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.values)
}
inline std::string* IOInfo::mutable_values() {
  std::string* _s = _internal_mutable_values();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.values)
  return _s;
}
inline const std::string& IOInfo::_internal_values() const {
  return _impl_.values_.Get();
}
inline void IOInfo::_internal_set_values(const std::string& value) {
  
  _impl_.values_.Set(value, GetArenaForAllocation());
}
inline std::string* IOInfo::_internal_mutable_values() {
  
  return _impl_.values_.Mutable(GetArenaForAllocation());
}
inline std::string* IOInfo::release_values() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.values)
  return _impl_.values_.Release();
}
inline void IOInfo::set_allocated_values(std::string* values) {
  if (values != nullptr) {
    
  } else {
    
  }
  _impl_.values_.SetAllocated(values, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.values_.IsDefault()) {
    _impl_.values_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.values)
}

// string shapes = 2;
inline void IOInfo::clear_shapes() {
  _impl_.shapes_.ClearToEmpty();
}
inline const std::string& IOInfo::shapes() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.shapes)
  return _internal_shapes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IOInfo::set_shapes(ArgT0&& arg0, ArgT... args) {
 
 _impl_.shapes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.shapes)
}
inline std::string* IOInfo::mutable_shapes() {
  std::string* _s = _internal_mutable_shapes();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.shapes)
  return _s;
}
inline const std::string& IOInfo::_internal_shapes() const {
  return _impl_.shapes_.Get();
}
inline void IOInfo::_internal_set_shapes(const std::string& value) {
  
  _impl_.shapes_.Set(value, GetArenaForAllocation());
}
inline std::string* IOInfo::_internal_mutable_shapes() {
  
  return _impl_.shapes_.Mutable(GetArenaForAllocation());
}
inline std::string* IOInfo::release_shapes() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.shapes)
  return _impl_.shapes_.Release();
}
inline void IOInfo::set_allocated_shapes(std::string* shapes) {
  if (shapes != nullptr) {
    
  } else {
    
  }
  _impl_.shapes_.SetAllocated(shapes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.shapes_.IsDefault()) {
    _impl_.shapes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.shapes)
}

// string types = 3;
inline void IOInfo::clear_types() {
  _impl_.types_.ClearToEmpty();
}
inline const std::string& IOInfo::types() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.IOInfo.types)
  return _internal_types();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IOInfo::set_types(ArgT0&& arg0, ArgT... args) {
 
 _impl_.types_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.IOInfo.types)
}
inline std::string* IOInfo::mutable_types() {
  std::string* _s = _internal_mutable_types();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.IOInfo.types)
  return _s;
}
inline const std::string& IOInfo::_internal_types() const {
  return _impl_.types_.Get();
}
inline void IOInfo::_internal_set_types(const std::string& value) {
  
  _impl_.types_.Set(value, GetArenaForAllocation());
}
inline std::string* IOInfo::_internal_mutable_types() {
  
  return _impl_.types_.Mutable(GetArenaForAllocation());
}
inline std::string* IOInfo::release_types() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.IOInfo.types)
  return _impl_.types_.Release();
}
inline void IOInfo::set_allocated_types(std::string* types) {
  if (types != nullptr) {
    
  } else {
    
  }
  _impl_.types_.SetAllocated(types, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.types_.IsDefault()) {
    _impl_.types_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.IOInfo.types)
}

// -------------------------------------------------------------------

// Tensor

// uint64 tensor_id = 1;
inline void Tensor::clear_tensor_id() {
  _impl_.tensor_id_ = uint64_t{0u};
}
inline uint64_t Tensor::_internal_tensor_id() const {
  return _impl_.tensor_id_;
}
inline uint64_t Tensor::tensor_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.tensor_id)
  return _internal_tensor_id();
}
inline void Tensor::_internal_set_tensor_id(uint64_t value) {
  
  _impl_.tensor_id_ = value;
}
inline void Tensor::set_tensor_id(uint64_t value) {
  _internal_set_tensor_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.tensor_id)
}

// uint64 storage_id = 2;
inline void Tensor::clear_storage_id() {
  _impl_.storage_id_ = uint64_t{0u};
}
inline uint64_t Tensor::_internal_storage_id() const {
  return _impl_.storage_id_;
}
inline uint64_t Tensor::storage_id() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.storage_id)
  return _internal_storage_id();
}
inline void Tensor::_internal_set_storage_id(uint64_t value) {
  
  _impl_.storage_id_ = value;
}
inline void Tensor::set_storage_id(uint64_t value) {
  _internal_set_storage_id(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.storage_id)
}

// uint64 offset = 3;
inline void Tensor::clear_offset() {
  _impl_.offset_ = uint64_t{0u};
}
inline uint64_t Tensor::_internal_offset() const {
  return _impl_.offset_;
}
inline uint64_t Tensor::offset() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.offset)
  return _internal_offset();
}
inline void Tensor::_internal_set_offset(uint64_t value) {
  
  _impl_.offset_ = value;
}
inline void Tensor::set_offset(uint64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.offset)
}

// uint64 num_elem = 4;
inline void Tensor::clear_num_elem() {
  _impl_.num_elem_ = uint64_t{0u};
}
inline uint64_t Tensor::_internal_num_elem() const {
  return _impl_.num_elem_;
}
inline uint64_t Tensor::num_elem() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.num_elem)
  return _internal_num_elem();
}
inline void Tensor::_internal_set_num_elem(uint64_t value) {
  
  _impl_.num_elem_ = value;
}
inline void Tensor::set_num_elem(uint64_t value) {
  _internal_set_num_elem(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.num_elem)
}

// uint64 elem_bytes = 5;
inline void Tensor::clear_elem_bytes() {
  _impl_.elem_bytes_ = uint64_t{0u};
}
inline uint64_t Tensor::_internal_elem_bytes() const {
  return _impl_.elem_bytes_;
}
inline uint64_t Tensor::elem_bytes() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.elem_bytes)
  return _internal_elem_bytes();
}
inline void Tensor::_internal_set_elem_bytes(uint64_t value) {
  
  _impl_.elem_bytes_ = value;
}
inline void Tensor::set_elem_bytes(uint64_t value) {
  _internal_set_elem_bytes(value);
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.elem_bytes)
}

// string device = 6;
inline void Tensor::clear_device() {
  _impl_.device_.ClearToEmpty();
}
inline const std::string& Tensor::device() const {
  // @@protoc_insertion_point(field_get:ChakraProtoMsg.Tensor.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Tensor::set_device(ArgT0&& arg0, ArgT... args) {
 
 _impl_.device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChakraProtoMsg.Tensor.device)
}
inline std::string* Tensor::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:ChakraProtoMsg.Tensor.device)
  return _s;
}
inline const std::string& Tensor::_internal_device() const {
  return _impl_.device_.Get();
}
inline void Tensor::_internal_set_device(const std::string& value) {
  
  _impl_.device_.Set(value, GetArenaForAllocation());
}
inline std::string* Tensor::_internal_mutable_device() {
  
  return _impl_.device_.Mutable(GetArenaForAllocation());
}
inline std::string* Tensor::release_device() {
  // @@protoc_insertion_point(field_release:ChakraProtoMsg.Tensor.device)
  return _impl_.device_.Release();
}
inline void Tensor::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    
  } else {
    
  }
  _impl_.device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.device_.IsDefault()) {
    _impl_.device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChakraProtoMsg.Tensor.device)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChakraProtoMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ChakraProtoMsg::NodeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChakraProtoMsg::NodeType>() {
  return ::ChakraProtoMsg::NodeType_descriptor();
}
template <> struct is_proto_enum< ::ChakraProtoMsg::CollectiveCommType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChakraProtoMsg::CollectiveCommType>() {
  return ::ChakraProtoMsg::CollectiveCommType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_et_5fdef_2eproto
